<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/01/hello_world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/todo/</url>
    <content><![CDATA[<ol>
<li>c++,stl…</li>
<li>设计模式</li>
<li>算法</li>
<li>zk</li>
<li>cuda</li>
<li>并行</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>cmake</title>
    <url>/2024/01/compile/cmake/</url>
    <content><![CDATA[<blockquote>
<p>cmake的简单用法 </p>
</blockquote>
<span id="more"></span>

<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required()</span><br><span class="line">project()</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED True)</span><br></pre></td></tr></table></figure>
<!--more-->
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_compile_options(target PUBLIC|PRIVATE|INTERFACE -XX -XX -XX)</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</code></p>
<ul>
<li>cache:缓存变量的标志</li>
<li>docstring:描述，必须为字符串</li>
<li>force:强制改变缓存变量</li>
<li>使用:<code>$(MY_VARIABLE)</code></li>
</ul>
<h3 id="local-var"><a href="#local-var" class="headerlink" title="local var"></a>local var</h3><p>相当于局部变量</p>
<h3 id="cache-var"><a href="#cache-var" class="headerlink" title="cache var"></a>cache var</h3><p>相当于全局变量，CMake中的缓存变量都会保存在CMakeCache.txt文件中</p>
<h3 id="env-var"><a href="#env-var" class="headerlink" title="env var"></a>env var</h3><p><code>set(ENV&#123;variable_name&#125; value)</code><br><code>$ENV&#123;variable_name&#125;</code></p>
<h2 id="目标文件构建"><a href="#目标文件构建" class="headerlink" title="目标文件构建"></a>目标文件构建</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_executable(target source)</span><br><span class="line">add_library(target [STATIC|SHARED] source)</span><br></pre></td></tr></table></figure>
<p>路径问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 解决路径问题</span><br><span class="line">target_include_directories(target [PUBLIC|PRIVAE|INTERFACE] src_path)</span><br><span class="line">target_link_directories(target [PUBLIC|PRIVAE|INTERFACE] src_path)</span><br><span class="line"># 解决依赖问题</span><br><span class="line">target_link_libraries(target [PUBLIC|PRIVAE|INTERFACE] src_path)</span><br></pre></td></tr></table></figure>
<p>以上相当于给target添加属性，并通过<code>PUBLIC|PRIVATE|INTERFACE</code>控制传递性</p>
<ol>
<li>PUBLIC:自己使用且传递</li>
<li>PRIVATE:自己使用不传递</li>
<li>INTERFACE:自己不用且传递</li>
</ol>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_subdirectory(src_path)</span><br></pre></td></tr></table></figure>
<ol>
<li>调用子目录的CMakeLists</li>
<li>导入子目录的target,不需要指定路径了,但头文件仍然需要指定路径</li>
</ol>
<h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-main</span><br><span class="line">CMAKELISTS.txt</span><br><span class="line">-src</span><br><span class="line">--func.h</span><br><span class="line">--CMAKELISTS.txt</span><br></pre></td></tr></table></figure>
<h3 id="不使用子目录cmakelist"><a href="#不使用子目录cmakelist" class="headerlink" title="不使用子目录cmakelist"></a>不使用子目录cmakelist</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required()</span><br><span class="line">project(main)</span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED True)</span><br><span class="line"></span><br><span class="line">add_executable(main main.cpp)</span><br><span class="line">target_include_directories(main PUBLIC src)</span><br><span class="line">target_link_directories(main PUBLIC src)</span><br><span class="line">target_link_libraries(main func)</span><br></pre></td></tr></table></figure>
<h3 id="使用子目录cmakelist"><a href="#使用子目录cmakelist" class="headerlink" title="使用子目录cmakelist"></a>使用子目录cmakelist</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main cmakelists</span><br><span class="line">cmake_minimum_required()</span><br><span class="line">project(main)</span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br><span class="line">set(CMAKE_CXX_STANDARD_REQUIRED True)</span><br><span class="line"></span><br><span class="line">add_subdirectory(src)</span><br><span class="line"></span><br><span class="line">add_executable(main main.cpp)</span><br><span class="line">target_include_directories(main PUBLIC src)</span><br><span class="line">target_link_libraries(main func)</span><br><span class="line"></span><br><span class="line">// src cmakelists</span><br><span class="line">add_library(func STATIC naive.cpp)</span><br></pre></td></tr></table></figure>
<p>可以在src中的cmakelists中这样写,main中的<code>target_include_directories(main PUBLIC src)</code>就可以省略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(func STATIC naive.cpp)</span><br><span class="line">target_include_directories(func PUBLIC .)</span><br></pre></td></tr></table></figure>

<h2 id="使用共享库"><a href="#使用共享库" class="headerlink" title="使用共享库"></a>使用共享库</h2><h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h3><p><a href="https://cmake.org/cmake/help/latest/command/find_package.html#find-package">官方文档</a><br><code>find_package</code>本质上还是查找文件问题</p>
<ol>
<li>module模式</li>
<li>config模式</li>
</ol>
]]></content>
      <tags>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title>compile</title>
    <url>/2024/01/compile/compile/</url>
    <content><![CDATA[<blockquote>
<p>g++编译的过程，以及静态链接</p>
</blockquote>
<span id="more"></span>

<h2 id="程序的编译过程-g"><a href="#程序的编译过程-g" class="headerlink" title="程序的编译过程 g++"></a>程序的编译过程 g++</h2><p><img src="/pic/compile-1.png"><br><img src="/pic/compile-2.webp"><br>编译成的目标文件大致包括代码段，数据段，符号表。</p>
<ul>
<li>预处理 将<code>#include&lt;&gt;和#define</code>加入</li>
<li>编译 源代码-&gt;汇编语言</li>
<li>汇编 汇编语言-&gt;目标文件</li>
<li>链接 多个目标文件链接成可执行程序或库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gcc中的使用</span></span><br><span class="line">g++ -o #输出文件名</span><br><span class="line">g++ -E #预处理</span><br><span class="line">g++ -S #汇编文件</span><br><span class="line">g++ -c #目标文件</span><br><span class="line">g++ -I include_path #头文件目录</span><br><span class="line">g++ -L lib_path -l lib #库目录</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>attention</strong></p>
<ol>
<li>不同阶段编译器检查什么<ul>
<li>源文件-&gt;目标文件阶段 编译器只检查变量和函数是否声明</li>
<li>链接阶段 会检查是否定义</li>
<li>具体怎么链接的见后</li>
</ul>
</li>
<li>gcc是怎么查找头文件的<ul>
<li><code>-I</code>指定目录</li>
<li>当前目录<code>#include&quot;xxx&quot;</code></li>
<li>环境变量<code>C_INLCUDE_PATH</code>or<code>CPLUS_INCLUDE_PATH</code></li>
<li>默认目录<code>/usr/include /usr/local/include ...</code></li>
</ul>
</li>
<li>gcc是怎么找静态库的<ul>
<li><code>-L</code>指定目录</li>
<li>环境变量<code>LIBRARY_PATH</code>，若使用动态库在编译阶段也是这个环境变量，但是动态库运行时还需要指定<code>LD_LIBRARY_PATH</code></li>
<li>默认目录<code>/usr/lib /usr/local/lib</code></li>
</ul>
</li>
</ol>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接简单说就是，张三写了一些工具函数，包含了许多cpp，hpp文件。别人使用的时候首先需要include头文件这样可以生成目标文件，但之后要的链接文件，且使用者不知道要链接什么（使用者只能从头文件中了解该库的功能，并不知道具体实现），怎么办？所以张三就可以把这些cpp编译成目标文件然后打包成一个静态库，这样就把链接的活全部交给编译器，完美解决问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar crs xxx.a a.o b.o ...</span><br></pre></td></tr></table></figure>

<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*tree</span></span><br><span class="line"><span class="comment">project</span></span><br><span class="line"><span class="comment">-main.cpp</span></span><br><span class="line"><span class="comment">-lib</span></span><br><span class="line"><span class="comment">--a.cpp</span></span><br><span class="line"><span class="comment">--a.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/a.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> A_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A_HPP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc ./lib/a.cpp -c -o ./lib/a.o</span><br><span class="line">ar crs ./lib/liba.a ./lib/a.o</span><br><span class="line">gcc main.cpp -L ./lib -la -o test</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>
<p><strong>attention</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> A_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A_HPP</span></span><br><span class="line"><span class="comment">//这个语句只是保证一个cpp文件，include多个头文件时，若重复只包含（展开）一次</span></span><br><span class="line"><span class="comment">//当两个文件include同一个头文件时，链接时就可能出错！！！</span></span><br><span class="line"><span class="comment">//因此头文件中最好不要放定义</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamic link</title>
    <url>/2024/01/compile/dynamic-link/</url>
    <content><![CDATA[<blockquote>
<p>静态链接会导致，每一个程序要用一个库都要链接库的目标文件，这样在内存中同一个库会有多次拷贝造成浪费，动态链接就是解决这类问题。</p>
</blockquote>
<span id="more"></span>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>两种加载方式</p>
<ul>
<li>装入时加载 dynamic linking:常用的是这种</li>
<li>运行时加载 dynamic loading:这种一般是显示调用的</li>
</ul>
<h3 id="运行时查找动态库"><a href="#运行时查找动态库" class="headerlink" title="运行时查找动态库"></a>运行时查找动态库</h3><ul>
<li>动态库的路径查找有两步，第一步是编译链接时的查找，和静态库一致，检查变量函数是否声明定义，这部分涉及到符号表</li>
<li>编译时优先动态库，可以使用<code>-static</code>强制指定静态库</li>
<li>运行时的查找<ol>
<li><code>-Wl,-rpath=</code>指定</li>
<li><code>export LD_LIBRARY_PATH=$LD_BRARY_PATH:path</code></li>
<li>默认路径<code>/usr/lib ...</code></li>
<li>配置<code>/etc/ld.so.config</code>文件<br><code>-Wl</code>这里gcc实际上是一个上层工具，编译链接过程中调用了预处理器，编译器，汇编器，链接器，<code>-Wl,rpath=</code>就是将参数传递给链接器,链接器对应ld指令</li>
</ol>
</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*tree</span></span><br><span class="line"><span class="comment">project</span></span><br><span class="line"><span class="comment">-main.cpp</span></span><br><span class="line"><span class="comment">-lib</span></span><br><span class="line"><span class="comment">--a.cpp</span></span><br><span class="line"><span class="comment">--a.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/a.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;a.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> A_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A_HPP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd lib</span><br><span class="line">g++ a.cpp -fPIC -c -o a.o #-fPIC用于编译，生成位置无关代码</span><br><span class="line">g++ a.o xxx.o ... -shared -o liba.so #链接成动态库</span><br><span class="line">cd ..</span><br><span class="line">g++ main.cpp -L ./lib -la -Wl,-rpath=./lib -o test</span><br></pre></td></tr></table></figure>
<p><strong>重要的事</strong></p>
<ol>
<li>-fPIC生成位置无关代码，与内存,重定位有关的知识得补补</li>
</ol>
<h2 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h2><blockquote>
<p>在实际编译中，各种动态库调用，手写g++编译很麻烦且易出错，linux系统有一些工具帮忙</p>
</blockquote>
<h3 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h3><p>ldconfig命令：的用途主要是在默认搜寻目录&#x2F;lib和&#x2F;usr&#x2F;lib以及动态库配置文件&#x2F;etc&#x2F;ld.so.conf内所列的目录下，搜索出可共享的动态链接库（格式如lib.so）,进而创建出动态装入程序(ld.so)所需的连接和缓存文件。<br>缓存文件默认为&#x2F;etc&#x2F;ld.so.cache，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令ldconfig，此执行程序存放在&#x2F;sbin目录下。<br>ldconfig通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。</p>
<h3 id="lld"><a href="#lld" class="headerlink" title="lld"></a>lld</h3><p>查看可执行程序的共享库</p>
<h3 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h3><ul>
<li>pkg-config相当于一个库管理工具</li>
<li>需要库的开发者写好.pc文件，文件中会包含头文件和库文件的位置信息，pkgconfig会读取这些文件</li>
<li>pkgconfig可以在编译链接运行时发挥作用，可以大大简化gcc指令</li>
<li>默认路径是<code>/usr/lib/pkgconfig</code> 环境变量<code>PKG_CONFIG_PATH</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg-config --list-all</span><br><span class="line">pkg-config --modeversion name</span><br><span class="line">pkg-config --libs name</span><br><span class="line">pkg-config --cflags name</span><br><span class="line">g++ main.cpp -o test `pkg-config --libs --cflags name`</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="更高级的工具"><a href="#更高级的工具" class="headerlink" title="更高级的工具"></a>更高级的工具</h3><p>make，cmake</p>
]]></content>
      <tags>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title>elf</title>
    <url>/2024/01/compile/elf/</url>
    <content><![CDATA[<p>待施工</p>
]]></content>
      <tags>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile</title>
    <url>/2024/01/compile/makefile/</url>
    <content><![CDATA[<p>待施工</p>
]]></content>
      <tags>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title>cs267 Applications of Parallel Computers 2022</title>
    <url>/2024/01/course/cs267/</url>
    <content><![CDATA[<blockquote>
<p>cs267学习笔记<br><a href="https://docs.google.com/spreadsheets/d/1bNNzAyKwrM78xmoydtWCsKrOQCW4wUOPL0LTDXZwl8E/edit#gid=1941727831">course</a></p>
</blockquote>
<span id="more"></span>
<h2 id="01-introduction"><a href="#01-introduction" class="headerlink" title="01 introduction"></a>01 introduction</h2><ul>
<li>Performance &#x3D; parallelism    Efficiency &#x3D; locality</li>
<li>flop</li>
<li>law</li>
<li>overview<br><img src="/pic/cs267overview.png"></li>
</ul>
<h2 id="02-Memory-Hierarchies-and-Matrix-Multiplication"><a href="#02-Memory-Hierarchies-and-Matrix-Multiplication" class="headerlink" title="02 Memory Hierarchies and Matrix Multiplication"></a>02 Memory Hierarchies and Matrix Multiplication</h2><h3 id="寄存器分配策略"><a href="#寄存器分配策略" class="headerlink" title="寄存器分配策略"></a>寄存器分配策略</h3><h4 id="活跃变量分析"><a href="#活跃变量分析" class="headerlink" title="活跃变量分析"></a>活跃变量分析</h4><p>活跃：程序点p的变量a在某条程序流上，从p点到下一次被赋值前被使用<br><img src="/pic/cs267AllocReg-1.png"></p>
<ul>
<li>IN[B]:从程序块B入口处开始的所有活跃变量</li>
<li>OUT[B]:从程序块出口处的所有活跃变量，显然OUT[B]是B所有后继节点的并集</li>
</ul>
<p><img src="/pic/cs267AllocReg-2.png"></p>
<p><img src="/pic/cs267AllocReg-3.png"></p>
<blockquote>
<p>和编译原理Predict集好像，这类问题是逆向数据流问题，找个时间补补编译原理</p>
</blockquote>
<h4 id="图着色"><a href="#图着色" class="headerlink" title="图着色"></a>图着色</h4><h4 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h4><h3 id="Memary-Hierarchies"><a href="#Memary-Hierarchies" class="headerlink" title="Memary Hierarchies"></a>Memary Hierarchies</h3><p>存储层次就不写了，很熟<br><img src="/pic/cs267hide.png"></p>
<h4 id="Little’s-Law"><a href="#Little’s-Law" class="headerlink" title="Little’s Law"></a>Little’s Law</h4><p>concurrency &#x3D; latency * bandwidth<br>定律的目的是让系统匹配带宽，以隐藏时延。比如带宽是2bytes&#x2F;s，这是系统的最大处理能力，若时延为10s，则需要20bytes。。。能感觉出来意思，但在这个场景下很奇怪</p>
<h4 id="benchmark-method"><a href="#benchmark-method" class="headerlink" title="benchmark method"></a>benchmark method</h4><h3 id="Parallelism-within-single-processors"><a href="#Parallelism-within-single-processors" class="headerlink" title="Parallelism within single processors"></a>Parallelism within single processors</h3><p>单处理器下的parallelism</p>
<h4 id="instruction-level-parallelism-and-pipling"><a href="#instruction-level-parallelism-and-pipling" class="headerlink" title="instruction level parallelism and pipling"></a>instruction level parallelism and pipling</h4><p>流水线，没什么好说的，里面提到了<strong>Pipelining is also used within arithmetic units</strong></p>
<h4 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h4><h4 id="data-dependencies"><a href="#data-dependencies" class="headerlink" title="data dependencies"></a>data dependencies</h4><p>数据相关</p>
<h4 id="FMA"><a href="#FMA" class="headerlink" title="FMA"></a>FMA</h4><ol>
<li>乘加合并后指令数更少，时钟周期减少</li>
<li>精确度更高</li>
</ol>
<h3 id="Multiple-Matrix"><a href="#Multiple-Matrix" class="headerlink" title="Multiple Matrix"></a>Multiple Matrix</h3>]]></content>
      <tags>
        <tag>course</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu gemm</title>
    <url>/2024/01/cpu/cpu_gemm/</url>
    <content><![CDATA[<p>cpu的gemm</p>
<span id="more"></span>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="调换顺序"><a href="#调换顺序" class="headerlink" title="调换顺序"></a>调换顺序</h3><p><code>C(i,j)+=A(i,l)*B(l,j)</code><br>把j循环放最后！</p>
<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; k; l += <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>展开最外层的循环</p>
<h3 id="利用寄存器"><a href="#利用寄存器" class="headerlink" title="利用寄存器"></a>利用寄存器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; k; l += <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">double</span> reg0 = <span class="built_in">A</span>(i, l);</span><br><span class="line">            <span class="type">double</span> reg1 = <span class="built_in">A</span>(i, l + <span class="number">1</span>);</span><br><span class="line">            <span class="type">double</span> reg2 = <span class="built_in">A</span>(i, l + <span class="number">2</span>);</span><br><span class="line">            <span class="type">double</span> reg3 = <span class="built_in">A</span>(i, l + <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">C</span>(i, j) += reg0 * <span class="built_in">B</span>(l, j);</span><br><span class="line">                <span class="built_in">C</span>(i, j) += reg1 * <span class="built_in">B</span>(l + <span class="number">1</span>, j);</span><br><span class="line">                <span class="built_in">C</span>(i, j) += reg2 * <span class="built_in">B</span>(l + <span class="number">2</span>, j);</span><br><span class="line">                <span class="built_in">C</span>(i, j) += reg3 * <span class="built_in">B</span>(l + <span class="number">3</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>c++17 废除了register关键字，这里设置普通double变量，编译器会把其分配到寄存器中</p>
<h3 id="减少乘法"><a href="#减少乘法" class="headerlink" title="减少乘法"></a>减少乘法</h3><h2 id="SIMD指令集"><a href="#SIMD指令集" class="headerlink" title="SIMD指令集"></a>SIMD指令集</h2><ol>
<li>内联汇编&amp;编译器intrinsic函数</li>
</ol>
<p>cmake<br>benchmark<br>simd avx<br>gemm</p>
]]></content>
      <tags>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>google benchmark</title>
    <url>/2024/01/cpu/google_benchmark/</url>
    <content><![CDATA[<p>待施工</p>
]]></content>
      <tags>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2024/01/git/git/</url>
    <content><![CDATA[<p>git基本用法</p>
<span id="more"></span>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><h2 id="git模型"><a href="#git模型" class="headerlink" title="git模型"></a>git模型</h2><p>观察.git&#x2F;object目录<br>文件名均是哈希</p>
<ol>
<li>git add<br> 此时，每个文件会生成一个blob类型的object</li>
<li>git commit<br> 创建一个tree类型的object，内容为blob文件名<br> 创建一个commmit类型的object，内容为<strong>提交信息</strong>，<strong>tree类型的文件名</strong>，<strong>上一个commit类型的object的文件名</strong></li>
<li>各分支的head存储在refs&#x2F;head中<br>HEAD内容为当前工作分支的头</li>
</ol>
<p><img src="/pic/git-1.png"></p>
<h2 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h2><ol>
<li>git merge<br>git merge有两种合并策略<ul>
<li>快进合并(faster forward)：当前分支在待合并分支为线性关系，直接合并即可，不会产生merge commit<br> <img src="/pic/git-2.gif"></li>
<li>递归三路合并（这里简单化，只考虑三路合并）,把待合并分支的所有更改，生成一个新的commit接到当前分支。本次commit object会有两个parent指针，即指向条线的上一个commit object<br> <img src="/pic/git-3.gif"></li>
</ul>
</li>
<li>git rebase<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure>
<img src="/pic/git-4.gif"></li>
</ol>
<blockquote>
<p>两种合并注意方向</p>
</blockquote>
<ol start="3">
<li>git push<br>默认仅在 fast-forward 状态下才可以合并，即git push在远端指针不是本地指针的祖先时会拒绝覆盖。而 <code>–force</code>，可以让 Git 不进行这个检查，直接覆盖远端对应 master 指针的内容。</li>
</ol>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add remote</span><br><span class="line">git remote add origin https://github.com/LLittleHanhan/test.git</span><br><span class="line">git remote -v</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:10800</span><br><span class="line">git config --global http.proxy socks5://127.0.0.1:10800</span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line">git push -force</span><br><span class="line">git fetch</span><br><span class="line">git merge</span><br><span class="line">git pull --no-rebase</span><br><span class="line">git pull --rebase</span><br><span class="line"></span><br><span class="line">git branch</span><br><span class="line">git branch feature</span><br><span class="line">git checkout branch_name</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU control core</title>
    <url>/2024/01/gpu/control_core/</url>
    <content><![CDATA[<p>本篇是《通用图形处理器设计GPGPI编程模型与架构原理》的控制核心架构</p>
<span id="more"></span>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p><img src="/pic/gpgpuarch.png" alt="Alt text"></p>
<h3 id="前段-取指译码"><a href="#前段-取指译码" class="headerlink" title="前段 取指译码"></a>前段 取指译码</h3><ul>
<li>依据pc值从指令缓存中取指，经过指令译码单元，存入指令缓冲，每个warp需要保存一个PC</li>
</ul>
<h3 id="中段-调度发射"><a href="#中段-调度发射" class="headerlink" title="中段 调度发射"></a>中段 调度发射</h3><ul>
<li>解决数据相关，记分牌</li>
<li>分支管理，simt堆栈</li>
<li>寄存器文件和操作数收集器</li>
</ul>
<h3 id="后段-执行和写回"><a href="#后段-执行和写回" class="headerlink" title="后段 执行和写回"></a>后段 执行和写回</h3><ul>
<li>计算单元</li>
<li>访存单元</li>
</ul>
<h2 id="线程分支"><a href="#线程分支" class="headerlink" title="线程分支"></a>线程分支</h2><h3 id="谓词-predicate-寄存器"><a href="#谓词-predicate-寄存器" class="headerlink" title="谓词(predicate)寄存器"></a>谓词(predicate)寄存器</h3><p>gpgpu架构普遍采用显式的谓词寄存器，谓词寄存器为每个执行通道配备1bit寄存器用来控制通道是否打开</p>
<h3 id="simt堆栈"><a href="#simt堆栈" class="headerlink" title="simt堆栈"></a>simt堆栈</h3><p>根据每个线程的谓词寄存器可以形成线程束的活跃掩码信息<br><img src="/pic/gpgpusimt1.png"></p>
<ul>
<li>RPC：分支汇聚点（IPDOM）PC，一般由CFG（控制流图）分析得到</li>
<li>NPC：该分支内需要执行的下一条指令PC</li>
<li>TOS：栈顶指针</li>
</ul>
<p>具体分析：<br><img src="/pic/gpgpusimt2.png"></p>
<blockquote>
<p>reference：<br><a href="https://zhuanlan.zhihu.com/p/593248814">https://zhuanlan.zhihu.com/p/593248814</a><br><a href="https://zhuanlan.zhihu.com/p/636979440">https://zhuanlan.zhihu.com/p/636979440</a></p>
</blockquote>
<h3 id="分支屏障"><a href="#分支屏障" class="headerlink" title="分支屏障"></a>分支屏障</h3><p>simt堆栈会存在一些问题，比如死锁：<br><img src="/pic/gpgpubarrier.png"></p>
<h2 id="线程束调度"><a href="#线程束调度" class="headerlink" title="线程束调度"></a>线程束调度</h2><p>因为GPGPU切换线程的开销很小，因此可以通过大量线程束并发来隐藏访存时延，线程束的并发度由硬件资源决定<br>不同线程束的不同指令会交织执行，同一线程束的指令顺序执行</p>
<h3 id="基本调度策略"><a href="#基本调度策略" class="headerlink" title="基本调度策略"></a>基本调度策略</h3><p>就绪指令的基本条件</p>
<ol>
<li>指令已取到</li>
<li>相关性解决</li>
<li>执行单元可用</li>
</ol>
<p>未就绪的原因：</p>
<ol>
<li>pipeline busy 指令所需的功能单元忙</li>
<li>texture忙</li>
<li>constant缓存缺失</li>
<li>指令缓存缺失</li>
<li>memory throttle，大量访存操作尚未完成</li>
<li>memory dependency</li>
<li>线程等待同步</li>
<li>数据相关</li>
</ol>
<p>调度策略</p>
<ul>
<li>基本轮询，轮转</li>
<li>贪心策略，一直发射一个线程束的指令</li>
</ul>
<h2 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h2><p>一般的数据相关有三种</p>
<ul>
<li>RAW写后读</li>
<li>WAW写后写</li>
<li>WAR读后写</li>
</ul>
<p>后两种没有数据传递，由于采用相同的寄存器编号将不相关指令人为联系在一起，可以通过寄存器重命名消除<br>GPGPU中采用顺序执行，且GPGPU指令仍然需要多个周期完成，只可能发生两种相关</p>
<ul>
<li>RAW写后读</li>
<li>WAW写后写</li>
</ul>
<h3 id="记分牌算法"><a href="#记分牌算法" class="headerlink" title="记分牌算法"></a>记分牌算法</h3><h3 id="Tomasulo算法"><a href="#Tomasulo算法" class="headerlink" title="Tomasulo算法"></a>Tomasulo算法</h3><h3 id="GPGPU中的记分牌"><a href="#GPGPU中的记分牌" class="headerlink" title="GPGPU中的记分牌"></a>GPGPU中的记分牌</h3><h2 id="线程块的分配与调度"><a href="#线程块的分配与调度" class="headerlink" title="线程块的分配与调度"></a>线程块的分配与调度</h2>]]></content>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda c best practics guide</title>
    <url>/2024/01/gpu/cuda_best_practics_guide/</url>
    <content><![CDATA[<p>cuda官方文档</p>
<span id="more"></span>

<h2 id="memory-optimizations"><a href="#memory-optimizations" class="headerlink" title="memory optimizations"></a>memory optimizations</h2><h3 id="data-transfer-between-host-and-device"><a href="#data-transfer-between-host-and-device" class="headerlink" title="data transfer between host and device"></a>data transfer between host and device</h3><h3 id="global-memory-and-l2-cache"><a href="#global-memory-and-l2-cache" class="headerlink" title="global memory and l2 cache"></a>global memory and l2 cache</h3><blockquote>
<p>High Priority: Ensure global memory accesses are coalesced whenever possible.</p>
</blockquote>
<ol>
<li>For devices of compute capability 6.0 or higher, the requirements can be summarized quite easily: the concurrent accesses of the threads of a warp will coalesce into a number of transactions equal to <strong>the number of 32-byte transactions necessary</strong> to service all of the threads of the warp.</li>
<li>Memory allocated through the CUDA Runtime API, such as via cudaMalloc(), is guaranteed to be aligned to at least <strong>256 bytes</strong>.<br><a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#coalesced-access-to-global-memory">链接</a></li>
<li>对于cc6以上，一个内存事务就是32字节</li>
</ol>
]]></content>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda c</title>
    <url>/2024/01/gpu/cuda_c/</url>
    <content><![CDATA[<p>这篇是cuda c编程权威指南的学习笔记，书比较老，后续计划看官方文档和项目</p>
<span id="more"></span>
<h2 id="编程和执行模型"><a href="#编程和执行模型" class="headerlink" title="编程和执行模型"></a>编程和执行模型</h2><ul>
<li>人的角度：一个kernel函数对应一个grid，一个grid中有多个block，一个block中分多个thread</li>
<li>硬件角度：一个block分配在一个sm上，在block划分多个warp，warp之间抢占计算核心，warp是调度的基本单位</li>
<li>同步：warp天然同步，block内的warp可以使用<code>__syncthreads()</code>同步，block间没有同步机制</li>
<li>分支，wrap分化<blockquote>
<p><strong>SIMD</strong>：单指令多数据的执行属于向量机，这种机制的问题就是过于死板，不允许每个分支有不同的操作，所有分支必须同时执行相同的指令。<br><strong>SIMT</strong>：给所有thread广播指令，但不要求必须执行。<br><strong>分支</strong>：wrap遇到分支时所有thread都把if和else全部执行（近似）<img src="/pic/gpgpubranch.png" alt="Alt text"><br><strong>优化思路</strong>手动分配thread到不同的wrap</p>
</blockquote>
</li>
<li>sm会给block分配一套寄存器，因此上下文切换开销很少</li>
<li>多个warp抢占sm的core以充分利用计算资源：延迟隐藏</li>
<li>tips<ul>
<li>首先要考虑到线程块这一级别，确定一个线程块处理那些数据块，因为线程块内的线程可以同步</li>
<li>其次考虑线程束分化问题</li>
<li>主机和设备是并行的，<code>cudaDeviceReset()</code>同步主机和设备</li>
</ul>
</li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>这部分需要明确什么是我可以手动设置的，什么是透明的<br>先不管常量和纹理</p>
<table>
<thead>
<tr>
<th align="center">种类</th>
<th align="center">存储位置</th>
<th align="center">声明位置</th>
<th align="center">标识符</th>
<th align="center">RW</th>
<th align="center">作用域</th>
<th align="center">生命周期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器</td>
<td align="center">片上</td>
<td align="center">核函数</td>
<td align="center">——</td>
<td align="center">RW</td>
<td align="center">线程</td>
<td align="center">线程</td>
</tr>
<tr>
<td align="center">本地内存</td>
<td align="center">片外</td>
<td align="center">核函数</td>
<td align="center">——</td>
<td align="center">RW</td>
<td align="center">线程</td>
<td align="center">线程</td>
</tr>
<tr>
<td align="center">共享内存</td>
<td align="center">片上</td>
<td align="center">？</td>
<td align="center"><code>__shared__</code></td>
<td align="center">RW</td>
<td align="center">线程块</td>
<td align="center">线程块</td>
</tr>
<tr>
<td align="center">全局内存</td>
<td align="center">片外</td>
<td align="center">全局</td>
<td align="center"><code>__device__</code></td>
<td align="center">RW</td>
<td align="center">所有线程+主机</td>
<td align="center">所有线程+主机</td>
</tr>
</tbody></table>
<ul>
<li>缓存<ul>
<li>一级：和共享内存处于同一位置，可以手动划分两者大小<code>cudaFuncSetCacheConfig()</code></li>
<li>二级</li>
</ul>
</li>
</ul>
<h3 id="全局内存"><a href="#全局内存" class="headerlink" title="全局内存"></a>全局内存</h3><blockquote>
<p>主机代码不能直接访问设备变量，必须调用cuda API<strong>获取真正的内存地址</strong></p>
</blockquote>
<h4 id="编程方法"><a href="#编程方法" class="headerlink" title="编程方法"></a>编程方法</h4> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="comment">//静态</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">__device__ <span class="type">int</span> ga = <span class="number">0</span>;</span><br><span class="line">__device__ <span class="type">int</span> gb;<span class="comment">//要么直接初始化，要么调用cudaMemcpytoSymbol</span></span><br><span class="line"><span class="comment">//cudaMemcpytoSymbol(const void* symbol,const void* src,size_t count)</span></span><br><span class="line"><span class="built_in">cudaMemcpytoSymbol</span>(gb,&amp;a,<span class="built_in">sizeof</span>(<span class="type">int</span>))<span class="comment">//对于主机来说，gb只是个标识符，而不是一个内存地址</span></span><br><span class="line">gb = a;<span class="comment">//error</span></span><br><span class="line"><span class="built_in">cudaMemcpy</span>(&amp;gb,&amp;a,<span class="built_in">sizeof</span>(<span class="type">int</span>),cudaMemcpyHostToDevice); <span class="comment">// error</span></span><br><span class="line"><span class="comment">//一定要用cudaMemcpy的话，可以用下面的方法</span></span><br><span class="line"><span class="type">int</span> *temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cudaGetSymbolAddress</span>(&amp;temp,gb)</span><br><span class="line"><span class="built_in">cudaMemcpy</span>(&amp;temp,&amp;a,<span class="built_in">sizeof</span>(<span class="type">int</span>),cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态</span></span><br><span class="line"><span class="type">int</span>* gc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cudaMalloc</span>(&amp;gc,<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//这里传递的是指针的地址，即在gpu全局内存处申请一块空间，将该空间地址赋值给gc，也就是说gc指向gpu中的一块内存</span></span><br><span class="line"><span class="built_in">cudaMemcpy</span>();</span><br><span class="line"><span class="built_in">cudaFree</span>(gc);</span><br></pre></td></tr></table></figure>
<h4 id="固定内存cudaMallocHost"><a href="#固定内存cudaMallocHost" class="headerlink" title="固定内存cudaMallocHost()"></a>固定内存<code>cudaMallocHost()</code></h4><p>主机中操作系统的内存管理机制，虚拟内存+内存分页，进程的内存页可能会换出</p>
<blockquote>
<p>CUDA的驱动程序检查内存范围是否被锁定，然后它将使用不同的代码路径。锁定的内存存储在物理内存 (RAM) 中，因此设备可以在没有CPU帮助的情况下获取它（DMA，也称为异步副本；设备只需要物理页面列表）。非锁定内存在访问时会产生页面错误，并且它不仅存储在内存中（例如它可以在交换中），因此驱动程序需要访问非锁定内存的每一页，将其<strong>复制到固定缓冲区</strong>并传递到 DMA（同步，逐页复制）</p>
</blockquote>
<h4 id="零拷贝内存cudaHostAlloc"><a href="#零拷贝内存cudaHostAlloc" class="headerlink" title="零拷贝内存cudaHostAlloc()"></a>零拷贝内存<code>cudaHostAlloc()</code></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaHostAlloc</span><span class="params">(<span class="type">void</span> ** pHost,<span class="type">size_t</span> count,<span class="type">unsigned</span> <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">//flag</span></span></span><br><span class="line"><span class="function"><span class="comment">//cudaHostAllocDefalt 同cudaMallocHost()</span></span></span><br><span class="line"><span class="function"><span class="comment">//cudaHostAllocPortable</span></span></span><br><span class="line"><span class="function"><span class="comment">//cudaHostAllocWriteCombined</span></span></span><br><span class="line"><span class="function"><span class="comment">//cudaHostAllocMapped 零拷贝</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设备不能直接使用pHost，需要转化为pDevice</span></span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaHostGetDevicePointer</span><span class="params">(<span class="type">void</span> ** pDevice,<span class="type">void</span> * pHost,<span class="type">unsigned</span> flags)</span></span>;<span class="comment">//UVA出现后就没用了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>零拷贝的是cpu固定内存</li>
<li>通过PCI-e远程访问，不再需要使用memcopy</li>
</ul>
<h4 id="统一虚拟寻址UVA-cuda2-0"><a href="#统一虚拟寻址UVA-cuda2-0" class="headerlink" title="统一虚拟寻址UVA cuda2.0"></a>统一虚拟寻址UVA cuda2.0</h4><p>UVA提出了零拷贝内存，即设备可以直接访问主机内存（单向），是否一定要是零拷贝？</p>
<blockquote>
<p>UVA启用了zero-copy技术，在CPU端分配内存，将CUDA VA映射上去，通过PCI-E进行每个操作。而且注意，UVA永远不会为你进行内存迁移。</p>
</blockquote>
<h4 id="统一内存寻址-cuda6-0"><a href="#统一内存寻址-cuda6-0" class="headerlink" title="统一内存寻址 cuda6.0"></a>统一内存寻址 cuda6.0</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMallocManaged</span><span class="params">(<span class="type">void</span> ** devPtr,<span class="type">size_t</span> size,<span class="type">unsigned</span> <span class="type">int</span> flags=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>Unified memory在程序员的视角中，维护了一个统一的内存池，在CPU与GPU中共享。使用了单一指针进行托管内存，由系统来自动地进行内存迁移。</p>
<p>以上参考<br><a href="https://zhuanlan.zhihu.com/p/82651065">文章一</a><br><a href="https://www.cnblogs.com/maomaozi/p/16175725.html">文章二</a><br><a href="https://forums.developer.nvidia.com/t/unified-virtual-addressing-uva-vs-unified-memory-perceived-difference/72399">文章三</a></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2>]]></content>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA C++ Programming Guide</title>
    <url>/2024/01/gpu/cuda_programing_guide/</url>
    <content><![CDATA[<p>本篇记录CUDA C++ Programming Guide,以新的东西为主<br>大致看下来重要的是2，4，5，</p>
<span id="more"></span>
<h2 id="2-Programming-Modle"><a href="#2-Programming-Modle" class="headerlink" title="2.Programming Modle"></a>2.Programming Modle</h2><blockquote>
<p>两个新的东西，thread block cluster和Asynchronous SIMT Programming Model，这是新的架构提出的</p>
</blockquote>
<h3 id="thread-hierarchy"><a href="#thread-hierarchy" class="headerlink" title="thread hierarchy"></a>thread hierarchy</h3><ul>
<li>thread blcok clusters<br><img src="/pic/cuda_programing_guide.png"><blockquote>
<p>With the introduction of <strong>NVIDIA Compute Capability 9.0</strong>, the CUDA programming model introduces an optional level of hierarchy called Thread Block Clusters that are made up of thread blocks. Similar to how threads in a thread block are guaranteed to be co-scheduled on a streaming multiprocessor, thread blocks in a cluster are also guaranteed to be co-scheduled on a GPU Processing Cluster (GPC) in the GPU.</p>
</blockquote>
</li>
</ul>
<p>暂时没接触到，啥是GPC，TPC？<br><a href="https://loop.houmin.site/context/gpu-arch/">以H100，讲述了GPC的作用，但TPC呢？</a></p>
<h3 id="memory-hierarchy"><a href="#memory-hierarchy" class="headerlink" title="memory hierarchy"></a>memory hierarchy</h3><p>这个没啥东西</p>
<h3 id="Heterogeneous-Programming"><a href="#Heterogeneous-Programming" class="headerlink" title="Heterogeneous Programming"></a>Heterogeneous Programming</h3><ul>
<li>Unified Memory<br>统一内存</li>
</ul>
<h3 id="Asynchronous-SIMT-Programming-Model"><a href="#Asynchronous-SIMT-Programming-Model" class="headerlink" title="Asynchronous SIMT Programming Model"></a>Asynchronous SIMT Programming Model</h3><p>Starting with devices based on the NVIDIA Ampere GPU architecture, the CUDA programming model provides acceleration to memory operations via the asynchronous programming model<br>这个也不是很理解，用到再说mark</p>
<h3 id="Compute-Capability"><a href="#Compute-Capability" class="headerlink" title="Compute Capability"></a>Compute Capability</h3><p>简单记录一下<br>H100 Hopper 9.0<br>A100 Ampere 8.0<br>T4   Turing 7.5<br>V100 Volta  7.0<br>P100 Pascal 6.0<br>Maxwell,Kepler,Fermi</p>
<h2 id="3-Programming-Interface"><a href="#3-Programming-Interface" class="headerlink" title="3.Programming Interface"></a>3.Programming Interface</h2><h3 id="nvcc"><a href="#nvcc" class="headerlink" title="nvcc"></a>nvcc</h3><p>c&#x2F;c++和ptx通过nvcc编译成二进制代码sass<br><a href="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html">详细过程</a></p>
<h3 id="cuda-runtime"><a href="#cuda-runtime" class="headerlink" title="cuda runtime"></a>cuda runtime</h3><h4 id="device-memory"><a href="#device-memory" class="headerlink" title="device memory"></a>device memory</h4><ul>
<li>linear memory :Linear memory is allocated in a single unified address space</li>
<li>cuda arrays :CUDA arrays are opaque memory layouts optimized for texture fetching</li>
<li>cudamallocpitch cudamalloc3D</li>
</ul>
<h4 id="l2-cache"><a href="#l2-cache" class="headerlink" title="l2 cache"></a>l2 cache</h4><blockquote>
<p>Starting with CUDA 11.0, devices of compute capability 8.0 and above have the capability to influence persistence of data in the L2 cache, potentially providing higher bandwidth and lower latency accesses to global memory</p>
</blockquote>
]]></content>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU memary core</title>
    <url>/2024/01/gpu/memary_core/</url>
    <content><![CDATA[<p>本篇是《通用图形处理器设计GPGPI编程模型与架构原理》的存储架构<br><img src="/pic/gpgpumemary.png"></p>
<span id="more"></span>
<h2 id="寄存器文件"><a href="#寄存器文件" class="headerlink" title="寄存器文件"></a>寄存器文件</h2><ul>
<li>寄存器文件将32个线程的标量寄存器打包成一个线程束寄存器</li>
</ul>
<h3 id="并行多板块"><a href="#并行多板块" class="headerlink" title="并行多板块"></a>并行多板块</h3><ul>
<li>例如一条乘加指令需要读三个线程束寄存器，写一个线程束寄存器，读写操作最好在一个周期完成</li>
<li>gpgpu寄存器文件会采用多个板块（bank）的单端口模拟多端口访问</li>
</ul>
<p>无板块冲突的过程：</p>
<ol>
<li>译码指令存入流水线寄存器，以及线程束WID</li>
<li>仲裁器根据WID和寄存器编号，打开相应位置的板块</li>
<li>读取后经过交叉开关将数据传输到下一流水线寄存器</li>
<li>所有数据准备好后将指令送入执行单元</li>
<li>执行完成后写回</li>
</ol>
<p>有冲突时，延迟到下一个周期</p>
<blockquote>
<p>同一条指令的读操作可能产生板块冲突，不同指令之间的读写也可能冲突</p>
</blockquote>
<h3 id="操作数收集器"><a href="#操作数收集器" class="headerlink" title="操作数收集器"></a>操作数收集器</h3><p><img src="/pic/gpgpucollector.png"><br>这就相当于在流水线中间放了一个缓存箱<br>将解码的指令放入空闲的收集单元，同时指令的读写请求会加入到仲裁器中的某个板块的请求队列中。仲裁器最多对4个请求（不同板块）处理，将数据发送给收集器<br>当一个收集器单元所有操作数准备好后，就可以发送给执行单元</p>
<blockquote>
<p>按上述，不同的线程束可以同时访问寄存器文件只要板块不冲突即可<br>具体的时钟周期没讲明白，不过目前不是很重要？                                         </p>
</blockquote>
<h3 id="板块交错分布"><a href="#板块交错分布" class="headerlink" title="板块交错分布"></a>板块交错分布</h3><p>原</p>
<table>
<thead>
<tr>
<th align="center">bank1</th>
<th align="center">bank2</th>
<th align="center">bank3</th>
<th align="center">bank4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w0</td>
<td align="center">w1</td>
<td align="center">w2</td>
<td align="center">w3</td>
</tr>
<tr>
<td align="center">v0</td>
<td align="center">v1</td>
<td align="center">v2</td>
<td align="center">v3</td>
</tr>
</tbody></table>
<p>交错</p>
<table>
<thead>
<tr>
<th align="center">bank1</th>
<th align="center">bank2</th>
<th align="center">bank3</th>
<th align="center">bank4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w0</td>
<td align="center">w1</td>
<td align="center">w2</td>
<td align="center">w3</td>
</tr>
<tr>
<td align="center">v1</td>
<td align="center">v2</td>
<td align="center">v3</td>
<td align="center">v0</td>
</tr>
</tbody></table>
<h3 id="数据相关性"><a href="#数据相关性" class="headerlink" title="数据相关性"></a>数据相关性</h3><p>采用数据收集器可能会产生数据冲突，发射有顺序，但是到收集器后具体谁先取完数谁后取完数就无法控制</p>
<h2 id="L1缓存和共享存储器"><a href="#L1缓存和共享存储器" class="headerlink" title="L1缓存和共享存储器"></a>L1缓存和共享存储器</h2><p><img src="/pic/gpgpureg.png"><br>L1缓存和共享内存共用一套结构，编程人员可以手动调整两者的大小</p>
<h3 id="共享存储器"><a href="#共享存储器" class="headerlink" title="共享存储器"></a>共享存储器</h3><p>共享存储器分32板块，一个板块一个单元32bit（4B）<br>无冲突：一个线程束32和线程的访问地址落在32个板块上或者指向同一板块的同一位置<br>有冲突：不同线程访问地址在同一板块的不同地址</p>
<h4 id="无冲突的访问过程"><a href="#无冲突的访问过程" class="headerlink" title="无冲突的访问过程"></a>无冲突的访问过程</h4><ol>
<li>共享内存取数指令发射到load&#x2F;store单元</li>
<li>load&#x2F;store单元会识别请求和判断地址信息，识别出是共享内存请求，地址无板块冲突，之后交给仲裁器，绕过tag unit</li>
<li>如果是读请求，load&#x2F;store会同时给寄存器文件调度一个写操作</li>
<li>如果是写请求，会将待写入数据写入写缓冲，之后再写入SRAM阵列</li>
</ol>
<h4 id="有冲突的访问"><a href="#有冲突的访问" class="headerlink" title="有冲突的访问"></a>有冲突的访问</h4><p>把请求分为不冲突的多部分，第一部分正常请求，其他部分采用重播</p>
<ol>
<li>可以退回到指令缓存中重播，缺点占用了指令缓存，需要重新计算地址</li>
<li>可以在load&#x2F;store单元单独设置缓存空间重播</li>
</ol>
<h4 id="共享存储器加载的数据通路"><a href="#共享存储器加载的数据通路" class="headerlink" title="共享存储器加载的数据通路"></a>共享存储器加载的数据通路</h4><p>共享存储器最初的数据怎么加载？直接看图</p>
<h3 id="L1缓存"><a href="#L1缓存" class="headerlink" title="L1缓存"></a>L1缓存</h3><h4 id="cpu中的cache"><a href="#cpu中的cache" class="headerlink" title="cpu中的cache"></a>cpu中的cache</h4><ul>
<li>映射：全相连，直接映像，组相连</li>
<li>替换算法：FIFO，LRU</li>
<li>写策略：写直达，写回法</li>
<li>写不命中：写分配</li>
</ul>
<h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><ol>
<li>全局内存访问指令发射到load&#x2F;store单元</li>
<li>load&#x2F;store单元会识别请求和判断地址信息，拆分合并地址请求，之后交给仲裁器，同时给寄存器文件调度一个写操作</li>
<li>仲裁器检测tag是否命中，如果命中直接从板块中读取</li>
<li>如果不命中，并将请求写入mshr单元<blockquote>
<p>MSHR<br>On a cache hit, a request will be served by sending data to the register ﬁle immediately. On a cache miss, the miss handling logic will ﬁrst check the miss status holding register (MSHR) to see if the same request is currently pending from prior ones. If so, this request will be merged into the same entry and no new data request needs to be issued. Otherwise, a new MSHR entry and cache line will be reserved for this data request. A cache status handler may fail on resource unavailability events such as when there are no free MSHR entries, all cache blocks in that set have been reserved but still haven’t been ﬁlled, the miss queue is full, etc.<br>cahce不命中会把请求写入mshr单元，mshr单元会进行地址合并减少下一层次访存</p>
</blockquote>
</li>
<li>mshr单元处理后发送到mmu单元，mmu单元进行虚实地址转换读取数据并返回，1.通过fill unit填入最后写入cache（可能有涉及cache替换），并锁定这一行在被读取前不能被替换，2.告知load&#x2F;store重播该指令</li>
</ol>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>详细过程不写了，有几个点</p>
<ol>
<li>缓存行要能够部分写</li>
<li>写命中的策略：<ul>
<li>对于局部存储器（寄存器溢出部分），因为是线程私有，一般不会产生一致性问题，因此可以采用写回法</li>
<li>对于全局存储器可以采用写逐出，写入L2缓存，同时L1缓存置为无效</li>
</ul>
</li>
</ol>
<h2 id="全局存储器"><a href="#全局存储器" class="headerlink" title="全局存储器"></a>全局存储器</h2><p>全局存储器的地址合并要求在DRAM中连续</p>
<ul>
<li>地址对齐</li>
<li>合并访问</li>
</ul>
<p>按照cpu缓存理解，访存指令先访问cache，cache未命中，先取数，之后指令重放，若启用L1,粒度128B，若不启用L1,粒度32B</p>
]]></content>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>java env</title>
    <url>/2024/01/java/java_env/</url>
    <content><![CDATA[<p>java基础概念</p>
<span id="more"></span>
<h2 id="jdk和jvm"><a href="#jdk和jvm" class="headerlink" title="jdk和jvm"></a>jdk和jvm</h2><ul>
<li>jdk: 早期叫jdk1.X，之后叫java SE X，最常用的版本jdk1.8（java 8）</li>
<li>jvm： 执行java程序的虚拟机</li>
</ul>
<h2 id="java编译执行过程"><a href="#java编译执行过程" class="headerlink" title="java编译执行过程"></a>java编译执行过程</h2><ol>
<li>首先由.java文件编译成.class文件</li>
<li>之后将.class文件链接在jvm上执行<br><a href="https://zhuanlan.zhihu.com/p/74229762">javac编译</a></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-X-jdk</span><br></pre></td></tr></table></figure>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean </span><br><span class="line">mvn compiler # 编译</span><br><span class="line">mvn package # 制作jar包</span><br><span class="line">mvn install # 下载本的仓库</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux env var</title>
    <url>/2024/01/linux/linux_env_var/</url>
    <content><![CDATA[<p>linux环境变量</p>
<span id="more"></span>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>顺序从下到上<br><code>source XXX</code></p>
<ol>
<li>局部<br><code>export</code></li>
<li>用户<br><code>~/.bashrc</code><br><code>~/.bash_profile</code></li>
<li>系统<br><code>/etc/bashrc</code><br><code>/etc/profile</code><br><code>/etc/enviroment</code></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux package manage</title>
    <url>/2024/01/linux/linux_package_manage/</url>
    <content><![CDATA[<p>linux包管理</p>
<span id="more"></span>
<h2 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h2><h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><code>apt update</code></li>
<li><code>apt install</code></li>
<li><code>apt upgrade</code></li>
<li><code>apt remove</code></li>
<li><code>apt purge</code> #删除包同时删除配置文件</li>
<li><code>apt autoremove [--purge]</code> #自动删除无用包</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象代数（一）</title>
    <url>/2024/03/math/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0(%E4%B8%80)/</url>
    <content><![CDATA[<p>这部分是与群相关的内容</p>
<span id="more"></span>

<h2 id="群（G，-）"><a href="#群（G，-）" class="headerlink" title="群（G，*）"></a>群（G，*）</h2><ol>
<li>封闭性</li>
<li>结合律</li>
<li>单位元</li>
<li>逆元<blockquote>
<p>注意没有交换律</p>
</blockquote>
</li>
</ol>
<p>性质：</p>
<ul>
<li>有限群&amp;无限群</li>
<li>群里的单位元唯一</li>
<li>元素的逆元唯一</li>
</ul>
<h2 id="阿贝尔群"><a href="#阿贝尔群" class="headerlink" title="阿贝尔群"></a>阿贝尔群</h2><p>$G是阿贝尔群，任意a，b属于G，有(a<em>b)^t &#x3D; a^t</em>b^t$</p>
<h2 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h2><p>$有群（G，<em>），集合H是G的非空子集，且（H，</em>）也是一个群$</p>
<p>判断子群：</p>
<ol>
<li>任意a，b属于H，有$a*b^{-1} \in H$，则H是G的子群</li>
<li>H是有限集，且在运算*上满足封闭性（即有限+封闭）</li>
</ol>
<blockquote>
<p>模n加法群都是循环群<br>模n乘法群不一定是循环群，见原根<br>群&gt;阿贝尔群&gt;循环群</p>
</blockquote>
<h2 id="构造子群"><a href="#构造子群" class="headerlink" title="构造子群"></a>构造子群</h2><p>以阿贝尔群为基础构造子群</p>
<ol>
<li>$G^m$</li>
<li>$G{m} &#x3D; { a \in G | a^m &#x3D; e }$   <blockquote>
<p>这种方式是G中元素a到单位元的距离</p>
</blockquote>
</li>
</ol>
<h2 id="陪集"><a href="#陪集" class="headerlink" title="陪集"></a>陪集</h2><blockquote>
<p>可以用（模n）整数加法群为例，模n乘法群有点抽象</p>
</blockquote>
<p>$H是G的子群，a \in G 有 aH &#x3D; {a<em>h | h\in H}或Ha &#x3D; {h</em>a | h\in H}$  </p>
<ol>
<li>$a \in [a]_H$</li>
<li>$a \in H \Leftrightarrow [a]_H &#x3D; H$</li>
<li>$[a]_H &#x3D; [b]_H \Leftrightarrow a^{-1}*b \in H$</li>
</ol>
<h2 id="拉格朗日定理"><a href="#拉格朗日定理" class="headerlink" title="拉格朗日定理"></a>拉格朗日定理</h2><p>$G是有限群，H是G的任意子群，则 |H|是|G|的因子$</p>
<h2 id="正规子群"><a href="#正规子群" class="headerlink" title="正规子群"></a>正规子群</h2><p>一个子群的左右陪集相等<br>正规子群不一定是阿贝尔群,阿贝尔群一定是正规子群</p>
<h2 id="商群"><a href="#商群" class="headerlink" title="商群"></a>商群</h2><p>正规子群构造出的所有陪集的集合<br>$G&#x2F;N &#x3D; {[a]_N | a \in G}、二元运算[a]_N*[b]_N &#x3D; [a*b]_N$</p>
<h2 id="群同态"><a href="#群同态" class="headerlink" title="群同态"></a>群同态</h2><p>$f(a*b)&#x3D;f(a) \bigotimes f(b)$</p>
<ul>
<li>同态核：原像映射成单位元的元素</li>
<li>同态像：原像映射成新像，新像中的元素</li>
</ul>
<h2 id="群同构"><a href="#群同构" class="headerlink" title="群同构"></a>群同构</h2><p>同态映射可以是一对一（单射）或多对一、或满射<br>群同构是单射加满射，即完全相同</p>
<p>第一同构定理<br>$G&#x2F;Kerf \cong Imf$</p>
<h2 id="循环群和阶"><a href="#循环群和阶" class="headerlink" title="循环群和阶"></a>循环群和阶</h2><p>阶可以是有限阶和无限阶<br>群的阶：群中元素的个数<br>元素的阶：$a^m&#x3D;e$的最小正整数m<br>循环群的阶：有生成元g，g的阶是n，即$g^n&#x3D;e$，群中元素个数为n</p>
<ol>
<li>正整数d|n，n阶有限循环群有唯一d阶子群$&lt;g^{\frac{n}{d}}&gt;$</li>
<li>n阶有限循环群$<g>$，$g^k$的阶是$\frac{n}{gcd(n,k)}$<blockquote>
<p>假设$g^k的阶是m，有g^{km}&#x3D;e，即n|km，即km要是k和n的最小公倍数km&#x3D;lcm(n,k)&#x3D;\frac{n}{gcd(n,k)}$</p>
</blockquote>
</li>
<li>由2当k与n互素，$g^k$的阶为n，故n阶循环群有$\Phi(n)$个生成元</li>
<li>素数阶的群一定是有限循环群<blockquote>
<p>元素的阶一定是群的阶的因子，因为某个元素a，$a^1,a^2…$可以生成一个子群，之后由拉格朗日定理可知</p>
</blockquote>
</li>
<li>G是n阶有限循环群，d|n，G中的d阶元素有$\Phi(d)$个<blockquote>
<p>1+3</p>
</blockquote>
</li>
</ol>
<h2 id="循环群的同构"><a href="#循环群的同构" class="headerlink" title="循环群的同构"></a>循环群的同构</h2><ul>
<li>无限循环群同构于$Z$</li>
<li>有限循环群同构于$Z_n$</li>
</ul>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><blockquote>
<p>将循环群的性质具体到群$Z_n^*$</p>
</blockquote>
<p>$Z_n^*$的生成元g，$g^{\Phi(n)}\equiv 1 \pmod n$<br>原根存在条件，p是奇素数，e是正整数，$n&#x3D;1,2,4,p^e,2p^e$<br></h><br>找原根的方法：<br>对$a^{\Phi(n)} \equiv e \pmod n$，$\Phi(n)&#x3D;p_1^{e_1}p_2^{e_2}…p_r^{e_r}$<br>若存在$d|\Phi(n)$使$a^d \equiv e \pmod n$<br>一定有一个素数p，$d|\frac{\Phi(n)}{p}$，且$a^{\frac{\Phi(n)}{p}} \equiv e \pmod n$<br>因此将$\Phi(n)$质因数分解，之后判断每一个p是否有$a^{\frac{\Phi(n)}{p}} \equiv e \pmod n$，若没有则是生成元</p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象代数（二）</title>
    <url>/2024/04/math/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0(%E4%B8%89)/</url>
    <content><![CDATA[<p>这部分是有限域的内容</p>
<span id="more"></span>
<p>额，好像项目中用的有限域是大素数p，不是2的p次方幂。。。</p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象代数（二）</title>
    <url>/2024/03/math/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0(%E4%BA%8C)/</url>
    <content><![CDATA[<p>这部分是与环和域相关的内容</p>
<span id="more"></span>

<h2 id="环"><a href="#环" class="headerlink" title="环"></a>环</h2><ol>
<li>封闭性</li>
<li>结合律</li>
<li>单位元</li>
<li>逆元</li>
</ol>
<p>群：1,2,3,4<br>么半群：1,2,3<br>半群：1,2<br>广群：1<br><h><br>环： 加法群+乘法半群+分配律<br>加法单位元：零元$\theta$<br>乘法单位元：单位元$e$</p>
<h>
含幺环：加法群+乘法幺半群+分配律
交换环：加法群+乘法半群+乘法交换律+分配律


<h2 id="零元"><a href="#零元" class="headerlink" title="零元"></a>零元</h2><ul>
<li>$e&#x3D;\theta \rightarrow 平凡环：环中只有一个元素$<br>$e \neq \theta \rightarrow 非平凡环$</li>
<li>零因子：$ab&#x3D;\theta且a,b \neq \theta$</li>
</ul>
<h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><ul>
<li>整环：非平凡含幺交换环+<strong>无零因子</strong>，例：整数环，模n（素数）整数环<blockquote>
<p>这里$Z_n$，n要求素数，因为若n不为素数，则存在零因子 </p>
</blockquote>
</li>
<li>除环：${R&#x2F;{\theta},*}$是群，显然除环没有零因子</li>
<li>域：${R&#x2F;{\theta},*}$是阿贝尔群</li>
<li>域比整环多了有乘法逆元，域比除环多了乘法交换律</li>
<li>有限整环都是域</li>
</ul>
<p><img src="/../../pic/qhy.png"></p>
<h2 id="环的特征"><a href="#环的特征" class="headerlink" title="环的特征"></a>环的特征</h2><p>环的特征：存在最小的正整数m使得环中任意元素a，累加m次为零元</p>
<ul>
<li>含幺交换环：$ma&#x3D;m(e<em>a)&#x3D;me</em>a$，因此将环的特征转换成乘法单位元e的加法阶</li>
<li>整环：整环的特征是0或素数<blockquote>
<p>$me&#x3D;0，若m&#x3D;st(1&lt;s,t&lt;m)，则(se)*(te)&#x3D;0，即存在零因子，与整环矛盾$</p>
</blockquote>
</li>
<li>域的特征等于0或素数，有限域的特征是素数</li>
</ul>
<h2 id="子环和理想"><a href="#子环和理想" class="headerlink" title="子环和理想"></a>子环和理想</h2><h3 id="子环"><a href="#子环" class="headerlink" title="子环"></a>子环</h3><p>判断R的子环S：</p>
<ol>
<li>加法子群：$a-b \in S$</li>
<li>乘法封闭性：$ab \in S$</li>
</ol>
<blockquote>
<p>环和子环的单位元没有任何联系！<br>从加法角度，子环一定是正规子群，从乘法角度，子环只要求了封闭性和结合律</p>
</blockquote>
<h3 id="理想"><a href="#理想" class="headerlink" title="理想"></a>理想</h3><blockquote>
<p>正规子群–&gt;商群<br>理想子环–&gt;商环</p>
</blockquote>
<p>理想：R是环，I是R的非空子集</p>
<ol>
<li>加法子群：$a-b \in S$</li>
<li>乘法吸收律：$\forall r \in R,\forall a \in I \Rightarrow ra \in I(ar \in I)$</li>
</ol>
<p>主理想：$R是环，a \in R，aR(Ra)称为由a生成的主理想$</p>
<h3 id="商环"><a href="#商环" class="headerlink" title="商环"></a>商环</h3><blockquote>
<p>这里就解释为什么理想要求吸收律了</p>
</blockquote>
<p>用加法构造陪集<br>对于加法，即商群$[a]_I+[b]_I&#x3D;[a+b]_I$<br>对于乘法$[a]_I*[b]_I&#x3D;[ab]_I\(a+t)*(b+t’)&#x3D;ab+tb+at’+tt’\tb+at’要为理想中的元素$</p>
<blockquote>
<p>商环还有点东西，以及环同态，估计用不上，不看了</p>
</blockquote>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>数论</title>
    <url>/2024/03/math/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<p>这部分是与数论相关的内容</p>
<span id="more"></span>

<h2 id="整除性"><a href="#整除性" class="headerlink" title="整除性"></a>整除性</h2><p>$b|a \Leftrightarrow a&#x3D;qb，q \in Z$</p>
<ol>
<li>意义：b是a的因子</li>
<li>虽然是叫“整除性”，但描述的还是乘法,因此b可以为0</li>
<li>一些推论很简单，不写了</li>
</ol>
<h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><p>引理</p>
<ol>
<li>任何大于1的整数必有素因子</li>
<li>任何一个合数都有一个不超过$\sqrt{n}$的素因子<ul>
<li>反过来，所有素数$p \leq \sqrt{n}$都不能整除$n$，则$n$是素数</li>
</ul>
</li>
<li>算术基本定理：$n&#x3D; \pm p_1^{e_1}…p_r^{e_r}$，$p$为素数，表示唯一</li>
<li>欧几里德定理：素数有无穷多个</li>
</ol>
<h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>算法：欧几里德算法（辗转相除法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>) </span><br><span class="line">    <span class="built_in">gcd</span>(a,b) = a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">gcd</span>(a,b) = <span class="built_in">gcd</span>(b,r);<span class="comment">//r=a%b</span></span><br><span class="line"><span class="comment">//why? a=b*q+r 因此假设m是a和b的因子,那么m一定是r的因子</span></span><br></pre></td></tr></table></figure>
<p>算法：扩展欧几里德算法$as+bt&#x3D;gcd(a,b)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a=r0 b=r1</span><br><span class="line">r0=r1*q1+r2</span><br><span class="line">r1=r2*q2+r3</span><br><span class="line">...</span><br><span class="line">rn<span class="number">-1</span>=rn*qn</span><br><span class="line"></span><br><span class="line">s0=<span class="number">1</span> s1=<span class="number">0</span> t0=<span class="number">0</span> t1=<span class="number">1</span></span><br><span class="line">s_i+<span class="number">1</span>=s_i<span class="number">-1</span>-s_i*q_i</span><br><span class="line">t_i+<span class="number">1</span>=t_i<span class="number">-1</span>-t_i*q_i</span><br><span class="line">a*s_i+b*t_i=r_i</span><br></pre></td></tr></table></figure>

<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>算法：$lcm(a,b)&#x3D;\frac{a*b}{gcd(a,b)}$<br>算法：迭代加,这个明显在计算机计算会简单的多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8+   16   16+  24</span><br><span class="line">12   12+  24   24</span><br></pre></td></tr></table></figure>

<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>基本运算规则<br>$(a+b)\mod p &#x3D; (a \mod p + b \mod p) \mod p$<br>$(a-b)\mod p &#x3D; (a \mod p - b \mod p) \mod p$<br>$(a \times b)\mod p &#x3D; (a \mod p \times b \mod p) \mod p$</p>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><ol>
<li>有集合S，定义在S上的二元关系R，有以下性质，称为<strong>等价关系</strong><ul>
<li>自反性</li>
<li>对称性</li>
<li>传递性</li>
</ul>
</li>
<li><strong>同余关系</strong> $a \equiv b \pmod n \Leftrightarrow n|(a-b)$，其中$n$为正整数，注意哈，同余是一种关系</li>
<li>同余的运算法则若$a \equiv b \pmod n$<br>$a+m \equiv b+m \pmod n$<br>$a-m \equiv b-m \pmod n$<br>$a \times m \equiv b \times m \pmod n$<br>$a^m \equiv b^m \pmod n$</li>
</ol>
<h2 id="乘法逆元（倒数）"><a href="#乘法逆元（倒数）" class="headerlink" title="乘法逆元（倒数）"></a>乘法逆元（倒数）</h2><p>$ab \equiv 1 \pmod n$则a，b互为逆元</p>
<ol>
<li>只考虑n以内的数</li>
<li>$逆元存在 \Leftrightarrow gcd(a,n)&#x3D;1$</li>
</ol>
<p>算法：扩展欧几里德算法求逆元$as+nt&#x3D;gcd(a,n)&#x3D;1$，将上述等式模$n$有$as \equiv 1 \pmod n$</p>
<h2 id="一次同余方程"><a href="#一次同余方程" class="headerlink" title="一次同余方程"></a>一次同余方程</h2><ol>
<li>消去律 若$gcd(a,n)&#x3D;d$，有$az \equiv az’ \pmod n \Rightarrow z \equiv z’ \pmod {n&#x2F;d}$</li>
<li>有解的条件，若$gcd(a,n)&#x3D;d$，则$ax \equiv b \pmod n \Leftrightarrow d|b$，这里可以分下类$d$是否等于1</li>
</ol>
<h2 id="剩余类"><a href="#剩余类" class="headerlink" title="剩余类"></a>剩余类</h2><p>$Z_n &#x3D; {[0],[1]…[n-1]} $</p>
<h2 id="中国剩余定理CRT——解一次同余方程组"><a href="#中国剩余定理CRT——解一次同余方程组" class="headerlink" title="中国剩余定理CRT——解一次同余方程组"></a>中国剩余定理CRT——解一次同余方程组</h2><p>设两两互素的模数$n_1,n_2…,n_m$，以及任意的整数$a_1,a_2…,a_m$，设$n&#x3D;\prod_{i&#x3D;0}^{m}n_i$，方程组<br>$$<br>\begin{cases}<br>x \equiv a_1 \pmod {n_1}\<br>x \equiv a_2 \pmod {n_2}\<br>…\<br>x \equiv a_m \pmod {n_m}<br>\end{cases}<br>$$<br>必有解$a$，且有解$a’ \Leftrightarrow a \equiv a’ \pmod n$<br>证明：<br>$n_i^* &#x3D; \frac{n}{n_i}$<br>$gcd(n_i^*,n_i)&#x3D;1$<br>$n_i^{<em>-1}<em>n_i^</em> \equiv 1 \pmod {n_i}$<br>$n_i^{</em>-1}<em>n_i^</em> \equiv 0 \pmod {n_j} j \neq i$<br>$a&#x3D;\sum_{i&#x3D;1}^{m}n_i^{*-1}*n_i^**a_i$ </p>
<h2 id="欧拉函数——求与模数互素的数的个数（模数以内）"><a href="#欧拉函数——求与模数互素的数的个数（模数以内）" class="headerlink" title="欧拉函数——求与模数互素的数的个数（模数以内）"></a>欧拉函数——求与模数互素的数的个数（模数以内）</h2><p>$Z_n^*&#x3D;{Z_n中有乘法逆元的剩余类 }$<br>$对于所有正整数n，定义欧拉函数 \Phi(n) &#x3D; |Z_n^*|，且令\Phi(1)&#x3D;1$<br>性质</p>
<ol>
<li>$设两两互素的正整数n_1,…n_m，并设n&#x3D; \prod_{i&#x3D;1}^{m}n_i，有 \Phi(n)&#x3D;\prod_{i&#x3D;1}^{m} \Phi(n_i)$</li>
<li>$\Phi(p^k)&#x3D;p^{k-1}\Phi(p)$</li>
<li>$\Phi(p)&#x3D;p-1$</li>
</ol>
<h2 id="欧拉定理，费马小定理——模运算下的乘方"><a href="#欧拉定理，费马小定理——模运算下的乘方" class="headerlink" title="欧拉定理，费马小定理——模运算下的乘方"></a>欧拉定理，费马小定理——模运算下的乘方</h2><p>$a \in Z_n^*，使a^k \equiv 1 \pmod n称k为a在模n下的乘法阶$</p>
<ol>
<li><p>$a^0,a^1,…,a^{k-1}互不相同$</p>
</li>
<li><p>$欧拉定理：a \in Z_n^*，a^{\Phi(n)} \equiv 1 \pmod n,k|\Phi(n)$</p>
<blockquote>
<p>注意这里的a的条件，模n乘法群的集合是由0到n-1之间与n互素的所有整数构成</p>
</blockquote>
</li>
<li><p>$费马小定理：对于任意的素数p和整数a \in Z_p，a^p \equiv a \pmod p$</p>
</li>
<li><p>$定理：a在模n下的乘法阶为k，则a^m在模n下的乘法阶为\frac{k}{gcd(m,k)}$</p>
</li>
</ol>
<h2 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h2><p>$(Z_n^*)^2 &#x3D; { b^2 | b \in Z_n^*}$</p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>椭圆曲线</title>
    <url>/2024/04/math/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<p>这部分是与椭圆曲线相关的内容</p>
<span id="more"></span>]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(一)基本类型</title>
    <url>/2024/03/rust/rust(%E4%B8%80)%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>本篇介绍rust基本变量类型</p>
<span id="more"></span>

<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><h3 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h3><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3>]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(七)项目、包、模块</title>
    <url>/2024/03/rust/rust(%E4%B8%83)%E9%A1%B9%E7%9B%AE%E3%80%81%E5%8C%85%E3%80%81%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>了解rust的package,crate,module,看完就可以看大点项目了</p>
<span id="more"></span>

<ol>
<li>package &gt; crate &gt; module</li>
<li>一个项目就是一个package，项目中可能会有多个crate，一个crate中会有多个module</li>
</ol>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new project # 创建一个package，里面有一个二进制类型的crate</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--project</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  --cargo.toml</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  --src</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    --main.rs</span></span><br><span class="line"></span><br><span class="line">cargo new lib --lib # 创建一个package，里面有一个lib类型的crate</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  --cargo.toml</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  --src</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    --lib.rs</span> </span><br></pre></td></tr></table></figure>


<h2 id="crate"><a href="#crate" class="headerlink" title="crate"></a>crate</h2><ul>
<li>二进制类型的crate可以有多个可执行文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--project</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  --cargo.toml</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  --src</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    --main.rs</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">    --bin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      --test.rs</span></span><br><span class="line">cargo run --bin test.rs</span><br></pre></td></tr></table></figure></li>
<li>lib类型的crate只能有一个lib.rs文件</li>
<li>lib类型和二进制类型可以共存</li>
</ul>
<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --lib</span></span><br><span class="line"><span class="comment">//   --cargo.toml</span></span><br><span class="line"><span class="comment">//   --src</span></span><br><span class="line"><span class="comment">//     --lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lib.rs</span></span><br><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── eat_at_restaurant()</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist()</span><br><span class="line">     │   └── seat_at_table()</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order()</span><br><span class="line">         ├── serve_order()</span><br><span class="line">         └── take_payment()</span><br></pre></td></tr></table></figure>
<ul>
<li>引用方式<ul>
<li>绝对路径crate：<code>crate::front_of_house::hosting::add_to_waitlist()</code></li>
<li>相对路径self和super</li>
</ul>
</li>
<li>把module视作和函数一样的实体，同级可见，父无法访问子，子可以访问父</li>
<li>使用pub访问控制，注意pub只能控制当前的东西，不能连带控制内部</li>
</ul>
<h2 id="文件和module"><a href="#文件和module" class="headerlink" title="文件和module"></a>文件和module</h2><ul>
<li>本质上一个crate就一个文件，拆散后用<code>mod xxx;</code>连接</li>
<li>使用方法和上小节一样<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --src</span></span><br><span class="line"><span class="comment">//   --main.rs</span></span><br><span class="line"><span class="comment">//   --test.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.rs</span></span><br><span class="line"><span class="keyword">mod</span> test; <span class="comment">//相当于c中的include</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面是复杂的情况，以目前所看的代码为例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --src</span></span><br><span class="line"><span class="comment">//   --lib.rs</span></span><br><span class="line"><span class="comment">//   --poseidon/</span></span><br><span class="line"><span class="comment">//     --mod.rs</span></span><br><span class="line"><span class="comment">//     --matrix.rs</span></span><br><span class="line"><span class="comment">//     --... </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mod.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> matrix;</span><br></pre></td></tr></table></figure>

<h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><ul>
<li>引入范围：<ul>
<li>本crate中的mod</li>
<li>第三方包，需要在cargo.toml中更改[dependencies]</li>
</ul>
</li>
<li>相当于给目标起个别名，方便使用，具体是引用模块还是直接引用函数，需要具体情况具体分析</li>
<li>命名冲突问题  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>&#123;&#125;</code>或<code>*</code>引用多个目标</li>
</ul>
<h2 id="使用use的可见性问题"><a href="#使用use的可见性问题" class="headerlink" title="使用use的可见性问题"></a>使用use的可见性问题</h2><p>这个完全可以让编译器帮忙纠错</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个名为 `my_mod` 的模块</span></span><br><span class="line"><span class="keyword">mod</span> my_mod &#123;</span><br><span class="line">    <span class="comment">// 模块中的项默认具有私有的可见性</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">private_function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 `pub` 修饰语来改变默认可见性。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在同一模块中，项可以访问其它项，即使它是私有的。</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">indirect_access</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">private_function</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块也可以嵌套</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> nested &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">private_function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::private_function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。</span></span><br><span class="line">        <span class="comment">// `path` 必须是父模块（parent module）或祖先模块（ancestor module）</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::my_mod) <span class="keyword">fn</span> <span class="title function_">public_function_in_my_mod</span>() &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">public_function_in_nested</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">self</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_nested</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::nested::public_function_in_nested&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 `pub(super)` 语法定义的函数只在父模块中可见。</span></span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_super_mod</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called my_mod::nested::public_function_in_super_mod&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">call_public_function_in_my_mod</span>() &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;</span>);</span><br><span class="line">        nested::<span class="title function_ invoke__">public_function_in_my_mod</span>();</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        nested::<span class="title function_ invoke__">public_function_in_super_mod</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `pub(crate)` 使得函数只在当前包中可见</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">public_function_in_crate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::public_function_in_crate()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套模块的可见性遵循相同的规则</span></span><br><span class="line">    <span class="keyword">mod</span> private_nested &#123;</span><br><span class="line">        <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_nested::function()`&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;called `function()`&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 模块机制消除了相同名字的项之间的歧义。</span></span><br><span class="line">    <span class="title function_ invoke__">function</span>();</span><br><span class="line">    my_mod::<span class="title function_ invoke__">function</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有项，包括嵌套模块内的，都可以在父模块外部访问。</span></span><br><span class="line">    my_mod::<span class="title function_ invoke__">indirect_access</span>();</span><br><span class="line">    my_mod::nested::<span class="title function_ invoke__">function</span>();</span><br><span class="line">    my_mod::<span class="title function_ invoke__">call_public_function_in_my_mod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pub(crate) 项可以在同一个 crate 中的任何地方访问</span></span><br><span class="line">    my_mod::<span class="title function_ invoke__">public_function_in_crate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pub(in path) 项只能在指定的模块中访问</span></span><br><span class="line">    <span class="comment">// 报错！函数 `public_function_in_my_mod` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::nested::public_function_in_my_mod();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消该行的注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错！`private_function` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::private_function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错！`private_function` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::nested::private_function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行的注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错！ `private_nested` 是私有的</span></span><br><span class="line">    <span class="comment">//my_mod::private_nested::function();</span></span><br><span class="line">    <span class="comment">// 试一试 ^ 取消此行的注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>限制可见性语法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>)</span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::a)</span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">self</span>)</span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>)</span><br></pre></td></tr></table></figure>
<p>具体可以仔细看<code>my_mod::nested::public_function_in_my_mod();</code></p>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(三)字符串</title>
    <url>/2024/03/rust/rust(%E4%B8%89)%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(九)循环和Iterator</title>
    <url>/2024/03/rust/rust(%E4%B9%9D)%E5%BE%AA%E7%8E%AF%E5%92%8CIterator/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><img src="/pic/rust-iter.png"></p>
<h3 id="iter-collection-into-iter"><a href="#iter-collection-into-iter" class="headerlink" title="iter = collection.into_iter()"></a><code>iter = collection.into_iter()</code></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">IntoIterator</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">IntoIter</span>: <span class="built_in">Iterator</span>&lt;Item = <span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::IntoIter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为类型实现IntoIterator，可以将类型转换为迭代器</li>
<li>何为迭代器——实现Iterator特征的类型</li>
<li><code>IntoIter</code>类型迭代器会拿走<strong>被迭代值的所有权</strong></li>
</ul>
<h3 id="iter-collection-iter"><a href="#iter-collection-iter" class="headerlink" title="iter = collection.iter()"></a><code>iter = collection.iter()</code></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; [T] &#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Iter&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">		Iter::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Iter</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">	ptr: NonNull&lt;T&gt;,</span><br><span class="line">	end: *<span class="keyword">const</span> T,</span><br><span class="line">	_marker: PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Iter结构体实现了Iterator特征，Iter为迭代器</li>
<li>以上以slice类型为例，每种可迭代类型有单独的实现，如下<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">std::collections::binary_heap::Iter   BinaryHeap 元素上的迭代器。</span><br><span class="line">std::collections::btree_map::Iter     BTreeMap 条目上的迭代器。</span><br><span class="line">std::collections::btree_set::Iter     BTreeSet 项上的迭代器。</span><br><span class="line">std::collections::hash_map::Iter      HashMap 条目上的迭代器。</span><br><span class="line">std::collections::hash_set::Iter      HashSet 项上的迭代器。</span><br><span class="line">std::collections::linked_list::Iter   LinkedList 元素上的迭代器。</span><br><span class="line">std::collections::vec_deque::Iter     VecDeque 元素上的迭代器。</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="iter-collection-iter-mut"><a href="#iter-collection-iter-mut" class="headerlink" title="iter = collection.iter_mut()"></a><code>iter = collection.iter_mut()</code></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; [T] &#123;</span><br><span class="line">  	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iter_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> IterMut&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        IterMut::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">IterMut</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">	ptr: NonNull&lt;T&gt;,</span><br><span class="line">	end: *<span class="keyword">mut</span> T,</span><br><span class="line">	_marker: PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以很容易看出和<code>iter()</code>的区别</li>
</ul>
<h2 id="消费者与适配器"><a href="#消费者与适配器" class="headerlink" title="消费者与适配器"></a>消费者与适配器</h2><ul>
<li>返回迭代器类型的就是迭代器适配器，返回其他类型的就是消费者适配器<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">count</span>(<span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">usize</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(二)所有权和引用</title>
    <url>/2024/03/rust/rust(%E4%BA%8C)%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(五)模式匹配和解构</title>
    <url>/2024/03/rust/rust(%E4%BA%94)%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E8%A7%A3%E6%9E%84/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(八)测试</title>
    <url>/2024/03/rust/rust(%E5%85%AB)%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(六)方法、特征、泛型</title>
    <url>/2024/03/rust/rust(%E5%85%AD)%E6%96%B9%E6%B3%95%E3%80%81%E7%89%B9%E5%BE%81%E3%80%81%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>来看看方法，特征和泛型<br>泛型是一个复合类型或一个函数内部变量的多态，特征是类型的相似行为的多态。<br>泛型主要从函数角度看变量，特征是从变量角度看函数</p>
</blockquote>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="在结构体和方法中使用泛型"><a href="#在结构体和方法中使用泛型" class="headerlink" title="在结构体和方法中使用泛型"></a>在结构体和方法中使用泛型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123; <span class="comment">//这里结构体的类型就是Point&lt;T,U&gt;,T和U是表现形式，可以换成其他的！</span></span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123; <span class="comment">// 注意impl声明</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意声明</li>
<li>泛型字母只是标志，对应即可</li>
<li>turbofish语法<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();<span class="comment">//编译器无法推断类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">bool</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="type">Vec</span>::&lt;<span class="type">bool</span>&gt;::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在枚举中使用泛型"><a href="#在枚举中使用泛型" class="headerlink" title="在枚举中使用泛型"></a>在枚举中使用泛型</h3><h3 id="const泛型"><a href="#const泛型" class="headerlink" title="const泛型"></a>const泛型</h3><p>数值的泛型</p>
<blockquote>
<p>泛型具体类型也不是随便给的，有些限制，比如说给泛型T一个具体类型X，之后T要做比大小，但X不能比较，这时需要对泛型作类型限制，见特征</p>
</blockquote>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="特征约束"><a href="#特征约束" class="headerlink" title="特征约束"></a>特征约束</h3><ul>
<li>做参数<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;&#125; <span class="comment">//使用语法糖</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125; <span class="comment">//特征约束，这里item1和item2是同一类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重约束</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// where约束,约束太多</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>做返回值<br>这里就一个问题，整个函数的返回类型虽然未知，但是要固定一致<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//error 这里会返回两种类型，不确定</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        Post &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Weibo &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h3><p>这个之后补充</p>
<h3 id="关联特征"><a href="#关联特征" class="headerlink" title="关联特征"></a>关联特征</h3><p>可以理解为特征的泛型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认泛型特征"><a href="#默认泛型特征" class="headerlink" title="默认泛型特征"></a>默认泛型特征</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: RHS) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="同名调用"><a href="#同名调用" class="headerlink" title="同名调用"></a>同名调用</h3><p>规则：</p>
<ol>
<li>调用类型上的方法</li>
<li>调用特征上的方法<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is your captain speaking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person); <span class="comment">// 调用Pilot特征上的方法</span></span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person); <span class="comment">// 调用Wizard特征上的方法</span></span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>(); <span class="comment">// 调用Human类型自身的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上为正常方法，即含有&amp;self，若为关联函数，使用完全限定语法<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::<span class="title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="特征中使用特征约束"><a href="#特征中使用特征约束" class="headerlink" title="特征中使用特征约束"></a>特征中使用特征约束</h3><p>实现A特征之前要实现B</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">A</span>:B&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>在看的zk项目中，发现有很多泛型嵌套，乱七八糟的，有新的理解，记录一下。<br>以下是个人理解：<br>首先需要明确，泛型只是静态多态，编译期就要<strong>确定类型</strong>，因此代码中手动明确泛型的类型，或者编译器可以推断出类型<br>结构体，函数，特征中的泛型要什么时间明确，怎样明确呢</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">test</span>&lt;A, B&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">C</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>&lt;G&gt;(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&lt;F&gt; &#123;</span><br><span class="line">    sa: F,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;A, B, F&gt; test&lt;A, B&gt; <span class="keyword">for</span> <span class="title class_">S</span>&lt;F&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">C</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>&lt;G&gt;(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span>: A;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span>: B;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span>: F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = S &#123; sa: <span class="number">1</span> &#125;;</span><br><span class="line">    &lt;S&lt;<span class="type">i32</span>&gt; <span class="keyword">as</span> test&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt;&gt;::f::&lt;<span class="type">i32</span>&gt;(&amp;t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里手写了一个很丑的栗子</p>
<ul>
<li>结构体S的泛型类型是编译器推断出来的</li>
<li>关联特征必须在为结构体实现时明确指定，这点是特征泛型和关联特征的区别，特征泛型在实现时可以不用明确给出，但最迟要在使用的时候明确</li>
<li>完全限定性语法的另一个用途，指定特征的泛型</li>
<li>turbofish语法的用途，指定函数的泛型</li>
</ul>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(十)闭包</title>
    <url>/2024/03/rust/rust(%E5%8D%81)%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust(四)复杂类型</title>
    <url>/2024/03/rust/rust(%E5%9B%9B)%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust</title>
    <url>/2024/01/rust/rust/</url>
    <content><![CDATA[<p>rust函数的参数和返回值必须是确定大小<br>对于一个类型的特征函数，时刻注意是<code>self &amp;self &amp;mut self</code></p>
<span id="more"></span>
<h2 id="Rust的内存管理"><a href="#Rust的内存管理" class="headerlink" title="Rust的内存管理"></a>Rust的内存管理</h2><ul>
<li>rust中特别的地方是内存管理使用所有权机制，这涉及到赋值，传参，返回时的复制。可以将变量分为两类：<ul>
<li>堆上的变量，在栈会存在内容（指针，大小管理之类），没有实现<code>copy</code>方法，拷贝时只拷贝栈上内容，可用<code>clone</code>完全拷贝</li>
<li>基本类型的变量<strong>整数，浮点，布尔，简单元组，不可变引用</strong>只存在栈上，拷贝整块复制</li>
</ul>
</li>
</ul>
<h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//size</span></span><br><span class="line">std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;val);</span><br><span class="line">std::mem::<span class="title function_ invoke__">size_of</span>(<span class="keyword">type</span>);</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = &amp;b[<span class="number">1</span>..<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">j</span> = &amp;b;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;i));<span class="comment">//16 8+8</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;j));<span class="comment">//8  8</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;b));<span class="comment">//24 8+8+8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用为<strong>纯指针</strong></li>
<li>可变引用只能单独存在</li>
<li>存在引用原变量不能释放。</li>
<li>自动解指针？？？<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  	x:<span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  	<span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">      	<span class="keyword">let</span> <span class="variable">s</span> = <span class="keyword">self</span>.x;</span><br><span class="line">      	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">  	<span class="keyword">let</span> <span class="variable">a</span> = A&#123;x:<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>()&#125;;</span><br><span class="line">  	a.<span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>代码块会报错<code>cannot move out of self.x which is behind a shared reference</code>，目前个人理解，不可变引用改变了原变量</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">  	email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  	username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">  	active: <span class="literal">true</span>,</span><br><span class="line">  	sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须全部初始化，顺序随便。</li>
<li>必须要将结构体实例声明为可变的，才能修改其中的字段，Rust 不支持将某个结构体某个字段标记为可变。<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">  	email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">  	..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>可缩略初始化<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	a: <span class="type">u8</span>,</span><br><span class="line">	b: <span class="type">u32</span>,</span><br><span class="line">	c: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">a</span> = A &#123;</span><br><span class="line">		a: <span class="number">1</span>,</span><br><span class="line">		b: <span class="number">2</span>,</span><br><span class="line">		c: <span class="number">3</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125; &#123;:p&#125; &#123;:p&#125;&quot;</span>,&amp;a.a,&amp;a.b,&amp;a.c); </span><br><span class="line">	<span class="comment">//0x7ffca964560e 0x7ffca9645608 0x7ffca964560c</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;a));<span class="comment">//8</span></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">align_of_val</span>(&amp;a));<span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>内存分布：结构体内部数据堆栈同正常单个类型，结构体只是数据打包？</li>
<li>结构体中会存在对齐属性！Rust 会在必要的位置填充空白数据，以保证每一个成员都正确地对齐，同时整个类型的尺寸是对齐属性的整数倍。</li>
</ul>
<h2 id="枚举-匹配-模式"><a href="#枚举-匹配-模式" class="headerlink" title="枚举 匹配 模式"></a>枚举 匹配 模式</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">person</span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">name</span>(<span class="type">String</span>),</span><br><span class="line">	<span class="title function_ invoke__">age</span>(<span class="type">i32</span>),</span><br><span class="line">	location&#123;id:<span class="type">i32</span>,lo:<span class="type">String</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">a</span> = person::location &#123; id: <span class="number">1</span>, lo: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>() &#125;;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">b</span> = person::<span class="title function_ invoke__">age</span>(<span class="number">32</span>);</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">c</span> = person::<span class="title function_ invoke__">name</span>(<span class="string">&quot;world&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">match</span> a&#123;</span><br><span class="line">		person::<span class="title function_ invoke__">age</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i),</span><br><span class="line">		person::<span class="title function_ invoke__">name</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s),</span><br><span class="line">		person::location &#123; id, lo &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,id,lo),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">person</span>::<span class="title function_ invoke__">age</span>(s) = b&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> matches!(c,person::<span class="title function_ invoke__">name</span>(s) <span class="keyword">if</span> s == <span class="string">&quot;world&quot;</span>)&#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>match本身同loop为表达式，有返回值</li>
<li>三种匹配方法<code>if let</code> <code>match</code> <code>matches!</code><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">match</span> x &#123;</span><br><span class="line">		<span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),<span class="comment">//a</span></span><br><span class="line">		<span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;y&#125;&quot;</span>),<span class="comment">//b</span></span><br><span class="line">		_ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;y&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匹配顺序——a,b谁在前执行谁，</li>
<li>匹配范围 <code>1..=10</code><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> b&#123;</span><br><span class="line">    person::<span class="title function_ invoke__">age</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i),</span><br><span class="line">    person::<span class="title function_ invoke__">name</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s),</span><br><span class="line">    person::location &#123; id, lo &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,id,lo),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">person</span>::<span class="title function_ invoke__">age</span>(s) = b&#123;</span><br><span class="line">  	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样会报错？？目前推断是：解构过程中会破坏原来的变量，虽然b为i32没问题,但存在其他类型，编译器为了确保安全仍会报错？？</li>
<li>匹配守卫，匹配后加判断<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  	Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">match</span> msg &#123;</span><br><span class="line">		Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span> &#125; =&gt; &#123;</span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">		&#125;,</span><br><span class="line">		Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">		Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">		&#125;,</span><br><span class="line">		Message::Hello &#123; id &#125; <span class="keyword">if</span> id&gt;<span class="number">7</span> &amp;&amp; id&lt;<span class="number">20</span> =&gt;&#123;</span><br><span class="line">			<span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">		&#125;,</span><br><span class="line">		_ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">- `@`绑定</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><ul>
<li>之前的匹配即解构，下面是其他情况</li>
<li>枚举的解构即用上面的<code>match</code><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123; x, y &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//元组</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">a</span> = (<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(),<span class="number">3.0</span>);</span><br><span class="line">	<span class="keyword">let</span> (x,y,z) = a;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,x,y,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">let</span> [x,y,z] =arr;</span><br><span class="line">	<span class="keyword">let</span> [a,..,b] = arr;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>..</code>省略 <code>_</code>忽略（只使用<code>_</code>和使用以下划线开头的名称有些微妙的不同：比如<code>_x</code>仍会将值绑定到变量，而<code>_</code>则完全不会绑定）</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>使用泛型注意提前声明<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;T&gt;&#123; &#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; A&lt;T&gt;&#123; &#125;<span class="comment">//这里的T可以换成别的字母，做到对应即可</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;T&gt;()&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>const泛型，在数值上使用泛型</li>
<li></li>
</ul>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul>
<li>泛型是一个复合类型或一个函数内部变量的多态，特征是类型的相似行为的多态。个人理解，泛型主要从函数角度看变量，特征是从变量角度看函数</li>
<li>特征约束<code>&lt;T:&gt;</code>，语法糖<code>x:impl trait</code>，语法糖也可以作为函数返回类型，但是缺点是返回值没有多态，可以通过特征对象解决</li>
<li>特征对象<code>Box&lt;dyn trait&gt;</code></li>
</ul>
<h2 id="循环和Iterator"><a href="#循环和Iterator" class="headerlink" title="循环和Iterator"></a>循环和Iterator</h2><ul>
<li>loop是一个表达式，可以break返回值<br><img src="/pic/rust-iter.png"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iter = collection.into_iter();</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">IntoIterator</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">IntoIter</span>: <span class="built_in">Iterator</span>&lt;Item = <span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::IntoIter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, A: Allocator&gt; <span class="built_in">IntoIterator</span> <span class="keyword">for</span> <span class="title class_">Vec</span>&lt;T, A&gt; &#123;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">Item</span> = T;</span><br><span class="line">	<span class="keyword">type</span> <span class="title class_">IntoIter</span> = IntoIter&lt;T, A&gt;;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::IntoIter&#123;...&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">IntoIter</span>&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="string">&quot;allocator_api&quot;</span>, issue = <span class="string">&quot;32838&quot;</span>)]</span> A: Allocator = Global,</span><br><span class="line">&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) buf: NonNull&lt;T&gt;,</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) phantom: PhantomData&lt;T&gt;,</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) cap: <span class="type">usize</span>,</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) alloc: ManuallyDrop&lt;A&gt;,</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) ptr: *<span class="keyword">const</span> T,</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) end: *<span class="keyword">const</span> T, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>fn into_iter(self) -&gt; Self::IntoIter;</code>可以看出，<code>into_iter()</code>方法输入<code>self</code>，输出具有<code>Iterator</code>特征的关联类型。即所谓迭代器就是实现<code>Iterator</code>特征的类型</li>
<li>对于<code>Vec</code>来说，<code>into_iter()</code>输出的关联类型为<code>IntoIter&lt;T,A&gt;</code></li>
<li><code>IntoIter</code>类型迭代器会拿走<strong>被迭代值的所有权</strong><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iter = collection.iter();</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; [T] &#123;</span><br><span class="line">	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Iter&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">		Iter::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Iter</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">	ptr: NonNull&lt;T&gt;,</span><br><span class="line">	end: *<span class="keyword">const</span> T,</span><br><span class="line">	_marker: PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>这里先回顾一个问题，集合的切片和集合的自身借用的差别，<code>&amp;v</code>为纯指针，<code>&amp;[]</code>为指针+长度</li>
<li>这里的<code>iter()</code>传入切片，返回<code>Iter</code>类型，可以看到它只有始末指针<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; [T] &#123;</span><br><span class="line">  	<span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">iter_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> IterMut&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        IterMut::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">IterMut</span>&lt;<span class="symbol">&#x27;a</span>, T: <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">	ptr: NonNull&lt;T&gt;,</span><br><span class="line">	end: *<span class="keyword">mut</span> T,</span><br><span class="line">	_marker: PhantomData&lt;&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以很容易看出和<code>iter()</code>的区别<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="keyword">loop</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> cnt &gt;<span class="number">5</span>&#123;</span><br><span class="line">		<span class="keyword">break</span> cnt</span><br><span class="line">	&#125;</span><br><span class="line">	cnt+=<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>迭代器上的方法有两大类一类返回新的迭代器，一类返回值<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="string">&quot;sunface&quot;</span>, <span class="string">&quot;sunfei&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ages</span> = [<span class="number">18</span>, <span class="number">18</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fn count(self) -&gt; usize </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cnt</span> = names.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">count</span>();</span><br><span class="line">    <span class="comment">//fn last(self) -&gt; Option&lt;Self::Item&gt;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last</span> = names.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">last</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(last,<span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;sunfei&quot;</span>));</span><br><span class="line">    <span class="comment">//fn nth(&amp;mut self, n: usize) -&gt; Option&lt;Self::Item&gt; 返回第n个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = names.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">nth</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(second,<span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;sunfei&quot;</span>));</span><br><span class="line">    <span class="comment">//fn chain&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fn zip&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//fn enumerate(self) -&gt; Enumerate&lt;Self&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>生命周期机制是为了防止悬空指针</li>
<li>生命周期机制没有改变原来的生命</li>
<li>消除规则<ul>
<li>每一个引用参数都会获得独自的生命周期</li>
<li>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期</li>
<li>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code>或<code>&amp;mut self</code>，则<code>&amp;self</code> 的生命周期被赋给所有的输出生命周期<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="comment">//    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str &#123;</span></span><br><span class="line"><span class="comment">//       println!(&quot;Attention please: &#123;&#125;&quot;, announcement);</span></span><br><span class="line"><span class="comment">//       self.part</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>对于函数来说，参数<code>&#39;a</code>表示这个参数的生命标记为<code>&#39;a</code>，具体多长不知道，当有多个相同标记的参数时取小值。返回值<code>&#39;a</code>表示，返回值的生命周期要小于<code>&#39;a</code>标记。因为返回值只能是从参数获得的(<code>&#39;static</code> 情况除外）</li>
<li>结构体的标记表示，内部的生命要比外部的生命长<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span> &#123;</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">		<span class="keyword">self</span>.part</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>: <span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;b</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="symbol">&#x27;a</span> <span class="keyword">self</span>, announcement: &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样会报错，因为返回值为 <code>self.part</code> 标记为<code>&#39;a</code>，编译器无法判断<code>&#39;a</code>和<code>&#39;b</code>的关系</li>
<li><code>&#39;a:&#39;b</code>：<code>&#39;a</code>生命要比<code>&#39;b</code>长，因为返回值标记<code>&#39;b</code>说明返回值生命要比<code>&#39;b</code>短，而实际的返回值为<code>&#39;a</code><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NoCopyType</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>&gt; &#123;</span><br><span class="line">    a: &amp;<span class="symbol">&#x27;a</span> <span class="type">u32</span>,</span><br><span class="line">    b: &amp;<span class="symbol">&#x27;b</span> NoCopyType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修复函数的签名 */</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fix_me</span>(foo: &amp;Example) <span class="punctuation">-&gt;</span> &amp;NoCopyType</span><br><span class="line">&#123; foo.b &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">no_copy</span> = NoCopyType &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">example</span> = Example &#123; a: &amp;<span class="number">1</span>, b: &amp;no_copy &#125;;</span><br><span class="line">    <span class="title function_ invoke__">fix_me</span>(&amp;example);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_once</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//println!(&quot;&#123;&#125;&quot;, func(4));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = |z:<span class="type">usize</span>|&#123;z==x.<span class="title function_ invoke__">len</span>()&#125;;</span><br><span class="line">    <span class="title function_ invoke__">fn_once</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = ||&#123;</span><br><span class="line">      	<span class="keyword">let</span> <span class="variable">newx</span> =x;</span><br><span class="line">    &#125;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以把闭包看作一个结构体类型，实现<code>Fn</code> <code>FnMut</code> <code>FnOnce</code>特征，编译器会默认顺序选择合适的特征类型<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = |x:<span class="type">i32</span>|&#123;</span><br><span class="line">		num +=x;</span><br><span class="line">		num</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">f</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">f</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;num:&#123;&#125; x:&#123;&#125; y:&#123;&#125;&quot;</span>,num,x,y);<span class="comment">//20 15 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">move</span> |x:<span class="type">i32</span>|&#123;</span><br><span class="line">		num +=x;</span><br><span class="line">		num</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">f</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">f</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;num:&#123;&#125; x:&#123;&#125; y:&#123;&#125;&quot;</span>,num,x,y);<span class="comment">//10 15 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>move</code> 闭包在内存中存储所获得的环境变量（把它理解单独的一个栈帧），对于实现<code>Copy</code>特征的类型，不带<code>move</code>是复制指针，反之是复制变量到新的栈帧，与原变量无关。<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> =||&#123;</span><br><span class="line">		s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;f));<span class="comment">//8</span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">f</span>();</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">f</span>();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">	<span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> =<span class="keyword">move</span> ||&#123;</span><br><span class="line">		s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;f));<span class="comment">//24</span></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">f</span>();</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">y</span> = <span class="title function_ invoke__">f</span>();</span><br><span class="line">	<span class="comment">//println!(&quot;&#123;&#125;&quot;,s); 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于没实现<code>Copy</code>特征的类型，<code>move</code>涉及所有权转移<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">factory</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">if</span> x &gt; <span class="number">1</span>&#123;</span><br><span class="line">		<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x + num)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x - num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>闭包作为函数返回值</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li><code>Box&lt;T&gt;</code> 很形象，有个box装着一个存储在堆上的变量，返回一个指针</li>
<li><code>Box::leak</code><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125; &#123;:p&#125;&quot;</span>,a,&amp;a);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">deref</span>();</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125; &#123;:p&#125;&quot;</span>,b, &amp;b);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(b));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">x</span> = *a;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>,&amp;x);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;x));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">	<span class="keyword">let</span> <span class="variable">d</span> = &amp;c;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125; &#123;:p&#125;&quot;</span>,d, &amp;d);</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::mem::<span class="title function_ invoke__">size_of_val</span>(d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>deref</code>特征</li>
</ul>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>circom1</title>
    <url>/2024/01/zk/circom1/</url>
    <content><![CDATA[<p>circom基本语法</p>
<span id="more"></span>
<h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><ul>
<li><p>三类信号</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signal input a;</span><br><span class="line">signal b;</span><br><span class="line">signal output c;</span><br></pre></td></tr></table></figure>
</li>
<li><p>public &amp; private</p>
<ul>
<li>中间信号总是private</li>
<li>main component的输入信号可以指定public<code>component main &#123;public [in1,in2]&#125; = XXX();</code></li>
<li>输出信号是public，否则外部不可见</li>
</ul>
</li>
<li><p>var &amp; signal</p>
<ul>
<li><code>var a = 0;</code> 注意：<code>=</code>赋值操作没有返回值</li>
</ul>
</li>
</ul>
<h2 id="template-component"><a href="#template-component" class="headerlink" title="template &amp; component"></a>template &amp; component</h2><ul>
<li>templates是定义，components是实例化</li>
<li>templates不能嵌套<br></li>
<li>components实例化时要指定明确的值</li>
<li>main components的input signal是对外的接口有值，内部templates的input signal需要手动赋值</li>
<li>当components的input signal全都赋完值后才会实例化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template A(N1,N2)&#123;</span><br><span class="line">    signal input in;</span><br><span class="line">    signal output out; </span><br><span class="line">    out &lt;== N1 * in * N2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template wrong (N) &#123;</span><br><span class="line">    signal input a;</span><br><span class="line">    signal output b;</span><br><span class="line">    a &lt;== 1; //Exception caused by invalid assignment: signal already assigned</span><br><span class="line">    component c = A(a,N); // Every component instantiation must be resolved during the constraint generation phase</span><br><span class="line">    component c = A(1,1);//Component c is created but not all its inputs are initialized</span><br><span class="line">&#125;</span><br><span class="line">component main &#123;public [a]&#125; = wrong(1);</span><br></pre></td></tr></table></figure>
<ul>
<li>components可以先声明，然后在第二步中初始化。如果有几个初始化指令（在不同的执行路径中），它们都需要是同一模板的实例化（可能具有不同的参数值）</li>
<li>arrays of components不允许在定义时进行初始化，只能逐个组件进行实例化，所有components都必须是同一模板的实例<br></li>
<li>parallel关键字</li>
<li>custom模板</li>
</ul>
<h2 id="constraint"><a href="#constraint" class="headerlink" title="constraint"></a>constraint</h2><blockquote>
<p>总结<br>signal 和 var 本质上都是变量，区别在于:At compilation time, the content of a <strong>signal</strong> is always considered unknown<br>signal可以赋值var,这时var就是<strong>unknown</strong><br>模板实例化时只能使用确定值的变量<br><br></p>
</blockquote>
<blockquote>
<p>R1CS<br>这是一个约束系统，If we have an arithmetic circuit with signals s_1,…,s_n, then we define a constraint as an equation of the following form:<br><code>(a_1*s_1 + ... + a_n*s_n) * (b_1*s_1 + ... + b_n*s_n) + (c_1*s_1 + ... + c_n*s_n) = 0</code><br>circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be quadratic of the form A<em>B + C &#x3D; 0,<br>where A, B and C are linear combinations of signals. circom will apply some minor transformations on the defined constraints in order to meet the format A</em>B + C &#x3D; 0:</p>
</blockquote>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><ul>
<li>这个就是一个正常的函数，表示一个通用的计算过程</li>
</ul>
<h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><ul>
<li><code>include test.circom</code>同c++</li>
<li>编译时同g++ <code>-l</code>寻找文件路径</li>
</ul>
<h2 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//boolean conditional</span><br><span class="line">var z = x&gt;y?x:y;</span><br><span class="line">//boolean</span><br><span class="line">&amp;&amp; || !</span><br><span class="line">//relational operators</span><br><span class="line">&gt; &lt; &gt;= &lt;= == !=</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//arthmetic operators</span><br></pre></td></tr></table></figure>
<p><img src="/pic/circom.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//bitwise operators</span><br><span class="line">&amp; | ~ ^(异或) &gt;&gt; &lt;&lt;</span><br><span class="line">//arthmetic bitwise 均可+=</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>circom2</title>
    <url>/2024/01/zk/circom2/</url>
    <content><![CDATA[<p>circom的一个讲座，简单看看</p>
<span id="more"></span>
<h2 id="Albert-Rubio-Circom-2-0-A-Scalable-Circuit-Complier"><a href="#Albert-Rubio-Circom-2-0-A-Scalable-Circuit-Complier" class="headerlink" title="Albert Rubio: Circom 2.0:A Scalable Circuit Complier"></a>Albert Rubio: Circom 2.0:A Scalable Circuit Complier</h2><hr>
<p><a href="https://www.youtube.com/watch?v=zRngElDdUNE&ab_channel=Delendum">video</a></p>
<ul>
<li>two-folded<ol>
<li>describe the circuit</li>
<li>compute the witness    <blockquote>
<p>you have to consider these constraints are polynomial constraints so defining the constraints is not going to give you an effencient way to compute the witness in many cases. so then you have to provide another way to compute the witness.</p>
</blockquote>
</li>
</ol>
</li>
<li>three different instructions<ul>
<li><code>out === in1*in2</code> symbolic level only</li>
<li><code>out &lt;-- in1*in2</code> computation level only</li>
<li><code>out &lt;== in1*in2</code> both</li>
</ul>
</li>
<li>simplify<br><img src="/pic/circom2-1.png"></li>
</ul>
]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>commitment</title>
    <url>/2024/01/zk/commitment/</url>
    <content><![CDATA[<blockquote>
<p>承诺：是对一个既有的确定性的事实（敏感数据）进行陈诉，保证未来的某个时间有验证方可以验证承诺的真假，也就是说承诺当前时间的事实，未来不会发生变化。</p>
</blockquote>
<span id="more"></span>
<p>承诺的两个阶段：</p>
<ol>
<li>commit：对敏感数据m计算承诺c并公开</li>
<li>reveal：公开m验证</li>
</ol>
<p>两个特性</p>
<ol>
<li>hiding：reveal前不能verifier不能知道m</li>
<li>binding：proofer在commit后不能更改m</li>
</ol>
<h2 id="哈希承诺"><a href="#哈希承诺" class="headerlink" title="哈希承诺"></a>哈希承诺</h2><ul>
<li>commit: <code>c=hash(m)</code></li>
<li>reveal: proofer公开m，验证<code>c==hash(m)</code></li>
</ul>
<h2 id="Pedersen承诺"><a href="#Pedersen承诺" class="headerlink" title="Pedersen承诺"></a>Pedersen承诺</h2><ul>
<li>commit: <code>c=r*G+m*H</code> G,H为特定椭圆曲线上的生成点，r是盲因子，m是原始信息</li>
<li>reveal：proofer公开r，m，验证<code>c=r*G+v*H</code></li>
</ul>
<h2 id="多项式承诺"><a href="#多项式承诺" class="headerlink" title="多项式承诺"></a>多项式承诺</h2><p>怎么确定一个唯一的多项式</p>
<ol>
<li>系数</li>
<li>n阶，提供n+1个点值对<blockquote>
<p>FFT和IFFT提供这两种方法的转化</p>
</blockquote>
</li>
</ol>
<p>全部打开：</p>
<ul>
<li>commit：任取一点r计算<code>c=f(r)</code></li>
<li>reveal：proofer公开r和c，验证<code>c=f(r)</code></li>
</ul>
<p>部分打开:</p>
<ul>
<li>commit：任取一点r计算<code>c=f(r)</code></li>
<li>reveal:<br>1. proofer公开r，c<br>2. verifer随机选择z<br>3. proofer计算<code>s=f(z) t(x)=(f(x)-s)/(x-z) w=t(r)</code>发送s，w<br>4. verifer验证<code>f(r)-s==t(r)(r-z)</code>即<code>c-s==w(r-z)</code></li>
<li>这种方法没有暴露最初的多项式</li>
<li>但是有问题，原因在于verfier公开的z，因此要在加密空间上运算</li>
</ul>
<h2 id="kate承诺"><a href="#kate承诺" class="headerlink" title="kate承诺"></a>kate承诺</h2><ol>
<li>setup<ul>
<li>选择椭圆曲线生成元$G$，配对函数$e$，随机值$\alpha$</li>
<li>计算{$g,g^\alpha,g^{\alpha^2}…g^{\alpha^t}$}</li>
<li>丢弃$\alpha$</li>
</ul>
</li>
<li>commit<ul>
<li>令要承诺的多项式为$f(x)&#x3D;\displaystyle\sum^{j}_{i&#x3D;0}{a_ix^i}$</li>
<li>计算在$\alpha$点的值$c&#x3D;\displaystyle\prod^{j}_{i&#x3D;0}{(g^{\alpha^i})^{a_i}}$</li>
</ul>
</li>
</ol>
<ul>
<li>open reveal<ul>
<li>给出原始多项式$f(x)$，verifer验证</li>
</ul>
</li>
<li>create witness<ul>
<li>给定$m$，创造出一个新的多项式$g(x)&#x3D;\frac{f(x)-f(m)}{x-m}$<blockquote>
<p>可以注意到$f(x)-f(m)$具有$x&#x3D;m$的根，问题转化为proofer知道一个多项式可以被整除</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>cryptocurrency</title>
    <url>/2024/01/zk/cryptocurrency/</url>
    <content><![CDATA[<p>区块链中的一些东西</p>
<span id="more"></span>
<h2 id="数字签名和数字证书"><a href="#数字签名和数字证书" class="headerlink" title="数字签名和数字证书"></a>数字签名和数字证书</h2><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>这个问题之前研究过，简单来说是公私钥的加密解密</p>
<ul>
<li>公钥加密，私钥解密，保证公钥方的消息只有私钥方可以查看，即加密通信</li>
<li>私钥加密，公钥解密，用于签名</li>
<li><ul>
<li>具体过程：<br>私钥方<br><code>digest = hash(message)</code><br> <code>signature = Private(digest)</code><br><code>send signature message Public</code><br>共钥方<br><code>verify hash(message)==Public(signature)</code></li>
</ul>
</li>
</ul>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>证书即信任的起点，目的是保证公钥的正确性防止中间人攻击,简单来书就是在公钥上套上一层ca机构的签名<br><img src="/pic/cryptocurrency-ca.jpg"></p>
<h2 id="区块链和交易"><a href="#区块链和交易" class="headerlink" title="区块链和交易"></a>区块链和交易</h2><p>以下以比特币为背景</p>
<h3 id="Merkle哈希树"><a href="#Merkle哈希树" class="headerlink" title="Merkle哈希树"></a>Merkle哈希树</h3><p>结构很好理解<img src="/pic/cryptocurrency-merkle.png"><br>用途：</p>
<ul>
<li>快速比较两组数据</li>
<li>快速定位修改</li>
<li>零知识证明，比如证明者声称知道L1,可以由验证者给Hash0-1,Hash1让证明者计算根结点</li>
</ul>
<h3 id="区块链结构"><a href="#区块链结构" class="headerlink" title="区块链结构"></a>区块链结构</h3><h3 id="UTXO模型"><a href="#UTXO模型" class="headerlink" title="UTXO模型"></a>UTXO模型</h3><p>这种模型不直接记录用户资产，而是通过记录未花费的Output来计算资产，任何一笔资产都可以追根溯源<img src="/pic/cryptocurrency-utxo.webp"><br>实际情况可能是一对多，多对一等</p>
<h3 id="区块链中的交易"><a href="#区块链中的交易" class="headerlink" title="区块链中的交易"></a>区块链中的交易</h3><p>关于交易有几个问题</p>
<ul>
<li>怎么找到属于属于自己的UTXO，且别人不能用</li>
<li>一笔交易，除了交易双方的人的其他人能看到什么，信息隐蔽吗</li>
</ul>
<h3 id="zcash"><a href="#zcash" class="headerlink" title="zcash"></a>zcash</h3><p>zcash相较于bitcoin使用了zk-snarks协议，来看看用在了哪里，以及和hash的关系</p>
<ul>
<li>l1链</li>
<li>outsourcing computation</li>
</ul>
]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>gzkp</title>
    <url>/2024/01/zk/gzkp/</url>
    <content><![CDATA[<p>待施工</p>
<span id="more"></span>]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>plonk</title>
    <url>/2024/01/zk/plonk/</url>
    <content><![CDATA[<p>待施工</p>
<span id="more"></span>]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>poseidon hash</title>
    <url>/2024/01/zk/poseidon_hash/</url>
    <content><![CDATA[<p>poseidon hash，毕业论文方向！！！！！</p>
<span id="more"></span>
<p><a href="">poseidon的原始论文</a><br><a href="pdf/hades.pdf">hedes的原始论文</a></p>
<h2 id="Merkel-Damgard-sponge-function"><a href="#Merkel-Damgard-sponge-function" class="headerlink" title="Merkel-Damgard &amp; sponge function"></a>Merkel-Damgard &amp; sponge function</h2><ul>
<li>MD<br>md5和sha256就是这个结构<br><img src="/pic/poseidon-MD.png"></li>
<li>Sponge<br>这个是sha3算法（keccak算法）提出的新型结构<br><img src="/pic/poseidon-Sponge.png"></li>
</ul>
<h2 id="Substitution-Permutation-Network-Hades"><a href="#Substitution-Permutation-Network-Hades" class="headerlink" title="Substitution-Permutation Network &amp; Hades"></a>Substitution-Permutation Network &amp; Hades</h2><ul>
<li>代换置换网络，可以回顾aes<br>SPN网络通常由以下几个关键部分组成：</li>
<li>代换层（Substitution Layer）：这一部分通常使用S盒（Substitution Box）来进行代换操作。S盒是一个非线性的函数，将输入的比特序列映射到输出比特序列.</li>
<li>置换层（Permutation Layer）：这一部分涉及对数据进行比特置换操作，通常包括比特的置换、轮换或排列等操作。</li>
<li>轮函数（Round Function）：SPN网络通常包括多个轮次，每一轮都会对数据进行代换和置换操作。轮函数是每个轮次中所使用的代换和置换操作的组合。</li>
</ul>
<h2 id="Poseidon-hash"><a href="#Poseidon-hash" class="headerlink" title="Poseidon hash"></a>Poseidon hash</h2><p><img src="/pic/poseidon.webp"></p>
]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>r1cs</title>
    <url>/2024/01/zk/r1cs/</url>
    <content><![CDATA[<p>r1cs约束</p>
<span id="more"></span>

<blockquote>
<p>R1CS<br>这是一个约束系统，If we have an arithmetic circuit with signals s_1,…,s_n, then we define a constraint as an equation of the following form:<br><code>(a_1*s_1 + ... + a_n*s_n) * (b_1*s_1 + ... + b_n*s_n) + (c_1*s_1 + ... + c_n*s_n) = 0</code><br>circom allows programmers to define the constraints that define the arithmetic circuit. All constraints must be quadratic of the form A<em>B + C &#x3D; 0,<br>where A, B and C are linear combinations of signals. circom will apply some minor transformations on the defined constraints in order to meet the format A</em>B + C &#x3D; 0:</p>
</blockquote>
<blockquote>
<p>r1cs只是一种约束系统，还有plonkish，air等</p>
</blockquote>
<h2 id="如何生成约束"><a href="#如何生成约束" class="headerlink" title="如何生成约束"></a>如何生成约束</h2><ul>
<li>HDL：circom</li>
<li>Library: arkworks(rust)</li>
<li>PL: ZoKrates</li>
</ul>
]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>ZENO:A Type-based Optimization Framework for Zero Knowledge Neural Network Inference</title>
    <url>/2024/01/zk/zeno/</url>
    <content><![CDATA[<p>一篇论文</p>
<span id="more"></span>
<blockquote>
<p>We propose <strong>privacy type driven</strong> and <strong>tensor-type driven</strong> optimizations to further optimize the generated zkSNARK circuit</p>
</blockquote>
<h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><ul>
<li><p>zk-snarks nn , protect x or w , for inference</p>
</li>
<li><p>funtion -&gt; circuit -&gt; constraint -&gt; proof<br><img src="/pic/zeno-1.png"></p>
<ul>
<li>the first step is Generate, which takes a given arithmetic function F(x) and generates a circuit</li>
<li>the second step is Circuit Computation that condenses the circuit into constraints</li>
<li>the third step is Security Computation that generates proof</li>
</ul>
</li>
<li><p>latency<br><img src="/pic/zeno-2.png"></p>
</li>
<li><p>properties in the constraints</p>
<ul>
<li>privacy plays an important role where multiplying a public value and a private value does not lead to constraints. </li>
<li>the addition is “free” in zkSNARK in terms of not introducing constraints, since a large number of additions can be expressed in a single linear combination by incorporating into the linear combination of private values. </li>
<li>Third, in the circuit computation, children gate(e.g., 𝐺𝑎𝑡𝑒 1 to 𝐺𝑎𝑡𝑒 4 ) need to be computed before parent gates</li>
</ul>
</li>
</ul>
<h2 id="Privacy-type-Driven-Optimization"><a href="#Privacy-type-Driven-Optimization" class="headerlink" title="Privacy-type Driven Optimization"></a>Privacy-type Driven Optimization</h2><ol>
<li>We should introduce privacy only when necessary and exploit as many “free” operations as possible to reduce cost</li>
<li><strong>Privacy-aware Knit Encoding</strong><ul>
<li>prove the computation over two dot products<br> <img src="/pic/zeno-3.png"></li>
</ul>
</li>
</ol>
<h2 id="Tensor-type-Driven-Optimization"><a href="#Tensor-type-Driven-Optimization" class="headerlink" title="Tensor-type Driven Optimization"></a>Tensor-type Driven Optimization</h2><ol>
<li>We present our ZENO circuit as an efficient intermediate representation (IR) from high-level zkSNARK NN arithmetic function to low-level constraints.<br><img src="/pic/zeno-4.png"><ul>
<li>public w, private x</li>
<li>对向量点乘的优化，扩展加法门</li>
<li>如何从f到电路再到约束？f-&gt;电路：树从叶结点生成，电路-&gt;约束：从根节点遍历？</li>
<li>哪里慢了？</li>
</ul>
</li>
<li>We propose ZENO circuit for fully connected, convolution, and pooling layers as an extension to ZENO circuit for dot product.<br> <img src="/pic/zeno-5.png"></li>
</ol>
]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>zksnarks</title>
    <url>/2024/01/zk/zksnarks/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记关注协议大致过程。<br>ZK-SNARKS协议，是<code>Zero-Knowl­edge Suc­cinct Non-In­ter­ac­tive Ar­gu­ment of Knowl­edge</code> 的缩写，意思是简洁零知识非交互式论证。<br>可以把zk-SNARKS协议看成一系列组件拼装。<br>之后的工作是f-&gt;计算电路-&gt;R1CS，其他简单看看就好。</p>
</blockquote>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主要参考文献：</p>
<ul>
<li>这篇文章<strong>前半部分</strong>多项式证明比较易懂，从R1CS-&gt;QAP开始不大行，难懂！<a href="./reference/Why%20and%20How%20zk-SNARK%20Works:%20Definitive%20Explanation.pdf">链接</a>,这是中文翻译<a href="https://secbit.io/blog/tags/zero-knowledge-proof/">链接</a></li>
<li>这篇文章介绍详细作为重点<a href="./reference/zkSNARK_intro.pdf">链接</a></li>
<li>Vitalik Buterin的文章，R1CS-&gt;QAP解释很舒服<a href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">链接</a>这是中文翻译<a href="https://snowolf0620.xyz/index.php/zkp/435.html">链接</a></li>
<li>zcash官方科普文，这个简单看看作为补充<a href="https://electriccoin.co/blog/snark-explain/">链接</a>这是中文翻译<a href="https://blog.csdn.net/u010088996/article/details/96499169?spm=1001.2014.3001.5502">链接</a></li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="多项式证明"><a href="#多项式证明" class="headerlink" title="多项式证明"></a>多项式证明</h3><h3 id="同态加密-多项式盲估"><a href="#同态加密-多项式盲估" class="headerlink" title="同态加密-多项式盲估"></a>同态加密-多项式盲估</h3><h3 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h3><h3 id="系数知识测试（KCA）"><a href="#系数知识测试（KCA）" class="headerlink" title="系数知识测试（KCA）"></a>系数知识测试（KCA）</h3><h3 id="计算电路-R1CS-QAP"><a href="#计算电路-R1CS-QAP" class="headerlink" title="计算电路-&gt;R1CS-&gt;QAP"></a>计算电路-&gt;R1CS-&gt;QAP</h3><h2 id="Groth16"><a href="#Groth16" class="headerlink" title="Groth16"></a>Groth16</h2>]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2024/01/zk/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>加密算法</p>
<ul>
<li>双向加密 <ul>
<li>对称 AES</li>
<li>非对称 RSA ECC</li>
</ul>
</li>
</ul>
<p>这篇主要看加密算法的结构，在poseidon hash里面有类似的东西</p>
<span id="more"></span>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p><img src="/pic/aes-1.webp"></p>
<ol>
<li>分组，每组16字节</li>
<li>扩展密钥<br><img src="/pic/aes-2.webp"></li>
<li>轮密钥加</li>
<li>字节代替<br>使用S盒，即一张映射表，为什么查表？方便逆运算<blockquote>
<p>在密码学中，一个S盒（Substitution-box，替换盒）是对称密钥加密算法执行替换计算的基本结构。</p>
</blockquote>
</li>
<li>行位移</li>
<li>列混淆</li>
</ol>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><h2 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h2>]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法</title>
    <url>/2024/01/zk/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>先来看看一般hash算法的过程,重点是有什么运算，以sha256和md5为例。</p>
</blockquote>
<span id="more"></span>

<h2 id="sha2"><a href="#sha2" class="headerlink" title="sha2"></a>sha2</h2><p>sha256算法主要包括<strong>循环右移</strong>，<strong>右移</strong>，<strong>异或</strong>，<strong>加法</strong>运算</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p><img src="/pic/sha256-1.png"></p>
<ul>
<li>将原数据填充，其中原数据长度记录为64位bit</li>
</ul>
<h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><p><img src="/pic/sha256-2.png"></p>
<ul>
<li>第三步word的扩展方法：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">s0 = (w[i-<span class="number">15</span>] rightrotate <span class="number">7</span>) <span class="title function_ invoke__">xor</span> (w[i-<span class="number">15</span>] rightrotate <span class="number">18</span>) <span class="title function_ invoke__">xor</span> (w[i-<span class="number">15</span>] rightshift <span class="number">3</span>)</span><br><span class="line">s1 = (w[i-<span class="number">2</span>] rightrotate <span class="number">17</span>) <span class="title function_ invoke__">xor</span> (w[i-<span class="number">2</span>] rightrotate <span class="number">19</span>) <span class="title function_ invoke__">xor</span> (w[i-<span class="number">2</span>] rightshift <span class="number">10</span>)</span><br><span class="line">w[i] = s0 + s1 + w[i-<span class="number">16</span>] + w[i-<span class="number">7</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对每一个块（64word-32bit）进行处理"><a href="#对每一个块（64word-32bit）进行处理" class="headerlink" title="对每一个块（64word*32bit）进行处理"></a>对每一个块（64word*32bit）进行处理</h3><p><img src="/pic/sha256-3.png"></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">a0 = <span class="title function_ invoke__">h0</span>(<span class="number">0</span>)</span><br><span class="line">b0 = <span class="title function_ invoke__">h1</span>(<span class="number">0</span>)</span><br><span class="line">c0 = <span class="title function_ invoke__">h2</span>(<span class="number">0</span>)</span><br><span class="line">d0 = <span class="title function_ invoke__">h3</span>(<span class="number">0</span>)</span><br><span class="line">e0 = <span class="title function_ invoke__">h4</span>(<span class="number">0</span>)</span><br><span class="line">f0 = <span class="title function_ invoke__">h5</span>(<span class="number">0</span>)</span><br><span class="line">g0 = <span class="title function_ invoke__">h6</span>(<span class="number">0</span>)</span><br><span class="line">h0 = <span class="title function_ invoke__">h7</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// h0(0)~h7(0)是前8个质数（2，3，…，19）的平方根在2进制下的小数部分的前32位。</span></span><br><span class="line"><span class="comment">//再引入k[0..63]是前64个质数（2，3，…，311）的平方根在2进制下的小数部分的前32位。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算 x：</span></span><br><span class="line">Σa = (a0 rightrotate <span class="number">2</span>) <span class="title function_ invoke__">xor</span> (a0 rightrotate <span class="number">13</span>) <span class="title function_ invoke__">xor</span> (a0 rightrotate <span class="number">22</span>)</span><br><span class="line">maj = (a0 and b0) <span class="title function_ invoke__">xor</span> (a0 and c0) <span class="title function_ invoke__">xor</span> (b0 and c0)</span><br><span class="line">x = Σa + maj</span><br><span class="line"><span class="comment">//计算 y：</span></span><br><span class="line">Σe = (e0 rightrotate <span class="number">6</span>) <span class="title function_ invoke__">xor</span> (e0 rightrotate <span class="number">11</span>) <span class="title function_ invoke__">xor</span> (e0 rightrotate <span class="number">25</span>)</span><br><span class="line">ch = (e0 and f0) <span class="title function_ invoke__">xor</span> ((not e0) and g0)</span><br><span class="line">y = Σe + ch + <span class="title function_ invoke__">w</span>(<span class="number">0</span>) + <span class="title function_ invoke__">k</span>(<span class="number">0</span>) + h0</span><br><span class="line"><span class="comment">//计算最终的新数：</span></span><br><span class="line">a1 = x + y</span><br><span class="line">b1 = a0</span><br><span class="line">c1 = b0</span><br><span class="line">d1 = c0</span><br><span class="line">e1 = d0 + y</span><br><span class="line">f1 = e1</span><br><span class="line">g1 = f1</span><br><span class="line">h1 = g1</span><br></pre></td></tr></table></figure>
<p><img src="/pic/sha256-4.png"></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将最终结果与 h0(0)~h7(0)相加，得到 h0(1)~h7(1)：</span></span><br><span class="line"><span class="title function_ invoke__">h0</span>(<span class="number">1</span>) = <span class="title function_ invoke__">h0</span>(<span class="number">0</span>) + a64</span><br><span class="line"><span class="title function_ invoke__">h1</span>(<span class="number">1</span>) = <span class="title function_ invoke__">h1</span>(<span class="number">0</span>) + b64</span><br><span class="line"><span class="title function_ invoke__">h2</span>(<span class="number">1</span>) = <span class="title function_ invoke__">h2</span>(<span class="number">0</span>) + c64</span><br><span class="line"><span class="title function_ invoke__">h3</span>(<span class="number">1</span>) = <span class="title function_ invoke__">h3</span>(<span class="number">0</span>) + d64</span><br><span class="line"><span class="title function_ invoke__">h4</span>(<span class="number">1</span>) = <span class="title function_ invoke__">h4</span>(<span class="number">0</span>) + e64</span><br><span class="line"><span class="title function_ invoke__">h5</span>(<span class="number">1</span>) = <span class="title function_ invoke__">h5</span>(<span class="number">0</span>) + <span class="type">f64</span></span><br><span class="line"><span class="title function_ invoke__">h6</span>(<span class="number">1</span>) = <span class="title function_ invoke__">h6</span>(<span class="number">0</span>) + g64</span><br><span class="line"><span class="title function_ invoke__">h7</span>(<span class="number">1</span>) = <span class="title function_ invoke__">h7</span>(<span class="number">0</span>) + h64</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前一个块处理结束，开始处理后一个块</span></span><br><span class="line">a0 = <span class="title function_ invoke__">h0</span>(<span class="number">1</span>)</span><br><span class="line">b0 = <span class="title function_ invoke__">h1</span>(<span class="number">1</span>)</span><br><span class="line">c0 = <span class="title function_ invoke__">h2</span>(<span class="number">1</span>)</span><br><span class="line">d0 = <span class="title function_ invoke__">h3</span>(<span class="number">1</span>)</span><br><span class="line">e0 = <span class="title function_ invoke__">h4</span>(<span class="number">1</span>)</span><br><span class="line">f0 = <span class="title function_ invoke__">h5</span>(<span class="number">1</span>)</span><br><span class="line">g0 = <span class="title function_ invoke__">h6</span>(<span class="number">1</span>)</span><br><span class="line">h0 = <span class="title function_ invoke__">h7</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/pic/sha256-5.png"></p>
<h3 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h3><p>最后将h0(n)~h7(n)串联即256bit结果</p>
<h2 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h2><p>md5包含一些位运算，加法，移位运算</p>
<ol>
<li>md5预处理和分块sha256相同，IV为初始向量ABCD<br><img src="/pic/md5-1.png"></li>
<li>md5对一个块的压缩分<strong>4轮</strong>,每轮一个轮函数，每轮<strong>16次迭代</strong><br><img src="/pic/md5-2.png"></li>
<li>下图是每次<strong>迭代</strong>的过程，即下图的过程每轮要做16次<br><img src="/pic/md5-3.png"></li>
<li>下图是每轮的轮函数，即上图的g<br><img src="/pic/md5-4.png"><br><img src="/pic/md5-5.png"><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//X[k]是块（512bit）第k个（32bit）16*32=512,即每轮都会把该块用一遍，具体的k为</span></span><br><span class="line"><span class="comment">//取j为当前迭代轮次</span></span><br><span class="line"><span class="comment">//第一轮循环：k = j</span></span><br><span class="line"><span class="comment">//第二轮循环：k = (1 + 5 * j) % 16</span></span><br><span class="line"><span class="comment">//第三轮循环：k = (5 + 3 * j) % 16</span></span><br><span class="line"><span class="comment">//第四轮循环：k = (7 * j) % 16</span></span><br><span class="line"><span class="comment">//T[i]是通过查表得到</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp func</title>
    <url>/2024/01/cpp/base/cpp_func/</url>
    <content><![CDATA[<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ol>
<li>内联不局限与类成员函数</li>
<li><code>inline</code>后有实现才有意义</li>
<li>内联是编译器将函数定义（{…}之间的内容）在函数调用处展开，藉此来免去函数调用的开销</li>
<li>同时内联避免了重定义问题，强符号，弱符号？</li>
<li>内联的意义是将本文件中使用该内联函数的地方全部替换，如果内联函数fun()定义在某个编译单元A中，那么其他编译单元中调用fun()的地方将无法解析该符号，因为在编译单元A生成目标文件A.obj后，内联函数fun()已经被替换掉，A.obj中不再有fun这个符号，链接器自然无法解析。因此内联函数要定义在<strong>头文件</strong>中</li>
<li><a href="https://blog.csdn.net/qq_35902025/article/details/127912415">有空看看</a></li>
</ol>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><ul>
<li><p>可以作为函数重载的标志</p>
<ul>
<li>参数类型和顺序</li>
<li>引用和指针类型的const修饰</li>
<li>类中const函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; a)</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(a);<span class="comment">//f(int&amp;)</span></span><br><span class="line"><span class="built_in">f</span>(b);<span class="comment">//f(const int&amp;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>无法区分（重定义）</p>
<ul>
<li>返回值</li>
<li>值和值引用</li>
<li>缺省参数</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp init</title>
    <url>/2024/01/cpp/base/cpp_init/</url>
    <content><![CDATA[<p>cpp中的默认初始化，值初始化，零初始化</p>
<span id="more"></span>
<h2 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h2><p><a href="https://zh.cppreference.com/w/cpp/language/default_initialization#.E6.B3.A8.E8.A7.A3">cpp_reference</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">触发条件</span><br><span class="line">1. T obj</span><br><span class="line">2. new T</span><br><span class="line">3. 构造函数初始化器列表中未提及某个基类或非静态数据成员,且调用该构造函数</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ol>
<li>非类对象，不进行初始化</li>
<li>类对象，调用构造函数</li>
<li>数组类型，内部每个元素默认初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span>&#123;</span><br><span class="line">    <span class="type">int</span> mem;</span><br><span class="line">    <span class="built_in">T2</span>() &#123;&#125; <span class="comment">// &quot;mem&quot; 不在初始化器列表中</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 静态非类，进行两阶段初始化：</span></span><br><span class="line">       <span class="comment">// 1) 零初始化将 n 初始化为零</span></span><br><span class="line">       <span class="comment">// 2) 默认初始化不做任何事，令 n 保留为零</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;            <span class="comment">// 非类，不初始化，值不确定</span></span><br><span class="line">    std::string s;    <span class="comment">// 类，调用默认构造函数，值是 &quot;&quot;（空字符串）</span></span><br><span class="line">    std::string a[<span class="number">2</span>]; <span class="comment">// 数组，默认初始化其各元素，值是 &#123;&quot;&quot;, &quot;&quot;&#125;</span></span><br><span class="line">    T2 t2;            <span class="comment">// 调用用户提供的默认构造函数</span></span><br><span class="line">                      <span class="comment">// t2.mem 被默认初始化（为不确定值）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h2><p><a href="https://zh.cppreference.com/w/cpp/language/value_initialization">cpp_reference</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T&#123;&#125;</span><br><span class="line">new T&#123;&#125;</span><br><span class="line">class T&#123;</span><br><span class="line">    int mem</span><br><span class="line">    T():mem&#123;&#125;&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 以上三项的&#123;&#125;可以替换成（）</span><br><span class="line">T obj&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 以上的T是非聚合类型</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ol>
<li>T没有默认构造函数，或拥有<strong>用户提供</strong>的默认构造函数，则默认初始化</li>
<li>T有默认构造函数（不由用户提供），首先零初始化对象,…</li>
<li>T是数组，每个元素零初始化</li>
<li>其他都是零初始化<blockquote>
<p>用户提供user-provided:如果一个函数由用户声明且没有在它的首个声明被显式default或显式delete，那么它由用户提供</p>
</blockquote>
</li>
</ol>
<h2 id="零初始化"><a href="#零初始化" class="headerlink" title="零初始化"></a>零初始化</h2><p><a href="https://zh.cppreference.com/w/cpp/language/zero_initialization">cpp_reference</a><br>条件：</p>
<ol>
<li>在所有初始化之前对静态存储期的，不进行常量初始化的变量</li>
<li>值初始化的一部分情况</li>
<li>不够长初始化数组的剩余部分</li>
</ol>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init1</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init2</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init2</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init3</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init3</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Init3::<span class="built_in">Init3</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init4</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init4</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Init4::<span class="built_in">Init4</span>() &#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init5</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init5</span>()</span><br><span class="line">        : i&#123;&#125; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    Init1 ia1;</span><br><span class="line">    Init1 ia2&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Init1: &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i1.i: &quot;</span> &lt;&lt; ia1.i &lt;&lt; <span class="string">&quot;\t&quot;</span><span class="comment">//任意值</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i2.i: &quot;</span> &lt;&lt; ia2.i &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    Init2 ib1;</span><br><span class="line">    Init2 ib2&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Init2: &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i1.i: &quot;</span> &lt;&lt; ib1.i &lt;&lt; <span class="string">&quot;\t&quot;</span><span class="comment">//任意值</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i2.i: &quot;</span> &lt;&lt; ib2.i &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    Init3 ic1;</span><br><span class="line">    Init3 ic2&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Init3: &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i1.i: &quot;</span> &lt;&lt; ic1.i &lt;&lt; <span class="string">&quot;\t&quot;</span><span class="comment">//任意值</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i2.i: &quot;</span> &lt;&lt; ic2.i &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//任意值</span></span><br><span class="line"></span><br><span class="line">    Init4 id1;</span><br><span class="line">    Init4 id2&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Init4: &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i1.i: &quot;</span> &lt;&lt; id1.i &lt;&lt; <span class="string">&quot;\t&quot;</span><span class="comment">//指定值</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i2.i: &quot;</span> &lt;&lt; id2.i &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//指定值</span></span><br><span class="line"></span><br><span class="line">    Init5 ie1;</span><br><span class="line">    Init5 ie2&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Init5: &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i1.i: &quot;</span> &lt;&lt; ie1.i &lt;&lt; <span class="string">&quot;\t&quot;</span><span class="comment">//0</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;i2.i: &quot;</span> &lt;&lt; ie2.i &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp left or right value</title>
    <url>/2024/01/cpp/base/cpp_left_or_right_value/</url>
    <content><![CDATA[<p>待施工</p>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp memory</title>
    <url>/2024/01/cpp/base/cpp_memary/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> ga = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> gb = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_ga = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_gb = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_ga = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_gb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> la = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> lb = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_la = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_lb = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; endl;     <span class="comment">// 0x576450897154</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &amp;b &lt;&lt; endl;     <span class="comment">// 0x576450897164</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &amp;ga &lt;&lt; endl;    <span class="comment">// 0x576450897158</span></span><br><span class="line">    cout &lt;&lt; &amp;gb &lt;&lt; endl;    <span class="comment">// 0x57645089715c</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &amp;s_ga &lt;&lt; endl;  <span class="comment">// 0x576450897168</span></span><br><span class="line">    cout &lt;&lt; &amp;s_gb &lt;&lt; endl;  <span class="comment">// 0x57645089716c</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &amp;c_ga &lt;&lt; endl;  <span class="comment">// 0x576450895004</span></span><br><span class="line">    cout &lt;&lt; &amp;c_gb &lt;&lt; endl;  <span class="comment">// 0x576450895008</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &amp;la &lt;&lt; endl;  <span class="comment">// 0x7fff6aafda70</span></span><br><span class="line">    cout &lt;&lt; &amp;lb &lt;&lt; endl;  <span class="comment">// 0x7fff6aafda74</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &amp;s_la &lt;&lt; endl;  <span class="comment">// 0x576450897170</span></span><br><span class="line">    cout &lt;&lt; &amp;s_lb &lt;&lt; endl;  <span class="comment">// 0x576450897174</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// char* const s</span></span><br><span class="line">    <span class="type">char</span>* t = <span class="string">&quot;world&quot;</span>;   <span class="comment">// const char* t</span></span><br><span class="line">    cout &lt;&lt; &amp;s &lt;&lt; endl;  <span class="comment">// 地址为0x7fff6aafda82在栈区，内容为hello，即hello存储在栈区</span></span><br><span class="line">    cout &lt;&lt; &amp;t &lt;&lt; endl;  <span class="comment">// 地址为0x7fff6aafda78在栈区，内容为0x57645089500c为常量区，即world存储在常量区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>堆区</li>
<li>栈区</li>
<li>静态&#x2F;全局 变量</li>
<li>常量</li>
</ul>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line">A* p = <span class="keyword">new</span> A;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">void</span>* mem = <span class="keyword">operator</span> <span class="built_in">new</span>()<span class="comment">//内部调用malloc</span></span><br><span class="line"><span class="number">2.</span> p = <span class="built_in">static_cast</span>&lt;A*&gt;(mem)<span class="comment">//指针转换</span></span><br><span class="line"><span class="number">3.</span> p-&gt;A<span class="comment">//构造函数</span></span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ~<span class="built_in">A</span>()<span class="comment">//调用析构函数</span></span><br><span class="line"><span class="number">2.</span> <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">()</span><span class="comment">//内部调用free，删除类</span></span></span><br></pre></td></tr></table></figure>

<h3 id="malloc-calloc-realloc-alloca"><a href="#malloc-calloc-realloc-alloca" class="headerlink" title="malloc calloc realloc alloca"></a>malloc calloc realloc alloca</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="type">int</span> *p=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp point and array</title>
    <url>/2024/01/cpp/base/cpp_point_and_array/</url>
    <content><![CDATA[<span id="more"></span>
<p><strong>首先明确几个问题</strong></p>
<h2 id="数组指针-int-N"><a href="#数组指针-int-N" class="headerlink" title="数组指针 int (*)[N]"></a>数组指针 <code>int (*)[N]</code></h2><p><code>int (*)[N] = int[N] *</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*a)[<span class="number">3</span>];<span class="comment">//指向长度为三的数组</span></span><br><span class="line"><span class="built_in">int</span> (*a)[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//指向3*4的二维数组</span></span><br></pre></td></tr></table></figure>
<h2 id="查看变量类型"><a href="#查看变量类型" class="headerlink" title="查看变量类型"></a>查看变量类型</h2><blockquote>
<p>typeinfo头文件里的typeid函数，这个函数或者说操作符是C++为支持RTTI（Run-Time Type Identification)运行时类型识别而提供的操作符之一，RTTI使程序能够获取由基指针或引用所指向的对象的实际派生类型，即允许“用指向基类的指针或引用来操作对象”的程序能够获取到“这些指针或引用所指对象”的实际派生类型。另外的操作符主要还有dynamic_cast和static_cast</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#125;;</span><br><span class="line">    <span class="built_in">int</span> (*b)[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">int</span> (*c)[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> *d;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a: &quot;</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">&quot;\tsizeof(&amp;a): &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(&amp;a)&lt;&lt;<span class="string">&quot;\ttypeof(&amp;a): &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(&amp;a).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a: &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;\tsizeof(a): &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;<span class="string">&quot;\ttypeof(a): &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(a).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a[0]: &quot;</span>&lt;&lt;&amp;a[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\tsizeof(&amp;a[0]): &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(&amp;a[<span class="number">0</span>])&lt;&lt;<span class="string">&quot;\ttypeof(&amp;a[0]): &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(&amp;a[<span class="number">0</span>]).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a[0]: &quot;</span>&lt;&lt;a[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\tsizeof(a[0]): &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a[<span class="number">0</span>])&lt;&lt;<span class="string">&quot;\ttypeof(a[0]): &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(a[<span class="number">0</span>]).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;&amp;a[0][0]: &quot;</span>&lt;&lt;&amp;a[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\tsizeof(&amp;a[0][0]): &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(&amp;a[<span class="number">0</span>][<span class="number">0</span>])&lt;&lt;<span class="string">&quot;\ttypeof(&amp;a[0][0]): &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(&amp;a[<span class="number">0</span>][<span class="number">0</span>]).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a[0][0]: &quot;</span>&lt;&lt;a[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\tsizeof(a[0][0]): &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>])&lt;&lt;<span class="string">&quot;\ttypeof(a[0][0]): &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(a[<span class="number">0</span>][<span class="number">0</span>]).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="数组到指针的隐式转换"><a href="#数组到指针的隐式转换" class="headerlink" title="数组到指针的隐式转换"></a>数组到指针的隐式转换</h2><blockquote>
<p>目前看到的都是说转换发生在参数传递时，且只转换一次<br>其他情况也能解释的通，就先这样理解</p>
</blockquote>
<p><code>int a[3][4]</code><br>下表的变量名值相同但是类型不同！！！</p>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">类型</th>
<th align="center">转换</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>a</code></td>
<td align="center"><code>int[3][4]</code></td>
<td align="center"><code>int (*)[4]</code></td>
</tr>
<tr>
<td align="center"><code>&amp;a</code></td>
<td align="center"><code>int (*)[3][4]</code></td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>a[0]</code></td>
<td align="center"><code>int[4]</code></td>
<td align="center"><code>int*</code></td>
</tr>
<tr>
<td align="center"><code>&amp;a[0]</code></td>
<td align="center"><code>int (*)[4]</code></td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>a[0][0]</code></td>
<td align="center"><code>int</code></td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>&amp;a[0][0]</code></td>
<td align="center"><code>int*</code></td>
<td align="center">-</td>
</tr>
</tbody></table>
<h2 id="数组的”粒度”"><a href="#数组的”粒度”" class="headerlink" title="数组的”粒度”"></a>数组的”粒度”</h2><p><code>int a[3];</code></p>
<ul>
<li><code>a[1] = *(a+1)</code> 这两者等价,a类型int<em>，是指向int的指针，所以a+1为*<em>a的地址+4</em></em></li>
</ul>
<p><code>int a[3][4];</code></p>
<ul>
<li><code>a[1] = *(a+1)</code> 由上表a类型int[3][4],可以隐式转换为int (<em>)[4],所以a+1为第二行首地址**a的地址+4</em>4**</li>
<li><code>(&amp;a)[1] = *(&amp;a+1)</code> 由上表&amp;a的类型为int (*)[3][4],即粒度为整个二维数组</li>
</ul>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>其实上一节已经使用了，这里就不详细写，注意数组粒度即可<code>a[1]=*(a+1)</code><br><code>int a[3][4]</code><br>a[1][1]的索引过程</p>
<ol>
<li>a的类型int[3][4],隐式转换后为int (*)[4]即行指针，粒度为一行</li>
<li>a[1][1]从左到右运算，a[1]&#x3D;*(a+1)</li>
<li>a[1]的类型为int[4],再进行一次隐式转换为int*</li>
<li>(a[1])[1]就是一维数组索引，之后略</li>
</ol>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>以上，总结二维数组传参的方法<br>首先明确三个东西:</p>
<ol>
<li>参数值</li>
<li>参数类型</li>
<li>标识符</li>
</ol>
<p>传的参数肯定都是一样的——首地址，不同的形式类型不一样，即指针粒度不同,以下是正常的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[][<span class="number">4</span>])</span></span>;<span class="comment">//这里第一维可以省略是因为索引计算时没用到</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>(*a)[<span class="number">4</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">f</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下的传参也可，分析一下</p>
<ul>
<li>二维变一维，按一维索引<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>* a)</span></span>&#123;</span><br><span class="line">    a[i*<span class="number">4</span>+j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="built_in">f</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">f</span>(&amp;a[<span class="number">0</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li>
<li>三维？注意行参是a，类型为int (*)[3][4]<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">3</span>][<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>][i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="built_in">f</span>(&amp;a);</span><br></pre></td></tr></table></figure>
<strong>总结下来一句话，传的参数要和行参对应，因此要搞清楚传的东西到底是什么类型，看表！！！</strong></li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>二维数组和指针的指针有关系吗？<br>a：没啥关系，它们只是值一样，类型不一样，可以强制类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span>** p = <span class="number">0</span>;</span><br><span class="line">p = (<span class="type">int</span>**)a;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp scope and lifetime</title>
    <url>/2024/01/cpp/base/cpp_scope_and_lifetime/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h2 id="static-和-extern"><a href="#static-和-extern" class="headerlink" title="static 和 extern"></a>static 和 extern</h2><ul>
<li>静态无链接：函数内使用static</li>
<li>静态内链接：函数外使用static</li>
<li>静态外链接：函数外直接声明定义<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b = <span class="number">1</span>;<span class="comment">//error,链接时redefine</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>summer：两个原则，1.任何变量和函数使用前至少要声明。2.单一定义</p>
</blockquote>
</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>全局const<ul>
<li><code>const int a = 0;</code>默认为内链接（static）</li>
<li>方便在头文件中使用，若为外链接，多个包含相同头文件的源文件会产生redefine</li>
<li>可以使用<code>extern const int a = 0;</code>覆盖</li>
</ul>
</li>
<li>指针常量和常量指针<ul>
<li><code>const int* a</code></li>
<li><code>int* const a</code></li>
</ul>
</li>
<li>从程序员角度引用起别名,内部实现是指针  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br><span class="line"><span class="type">int</span> &amp;c=b;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c<span class="comment">//1,1,1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="生存期和命名空间"><a href="#生存期和命名空间" class="headerlink" title="生存期和命名空间"></a>生存期和命名空间</h2><h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3><p><img src="/pic/cppscope-1.png"><br><img src="/pic/cppscope-2.png"></p>
<ol>
<li>声明域，全局变量-&gt;整个文件，函数中的局部变量-&gt;函数代码块，循环中局部变量-&gt;循环代码块</li>
<li>潜在作用域,从声明点到声明域结束</li>
<li>作用域，潜在作用域可能用命名冲突而覆盖</li>
</ol>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>只是一个“形式”，在使用using之前，这些变量没有声明和定义<br>命名空间的“形式”是全局的，不能在代码块中<br>命名空间里的变量一般具有外部链接性（除非const）<br>每个文件有一个全局命名空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> test&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><ul>
<li>直接使用作用域解析符</li>
<li>using声明,与普通声明一样,唯一区别，普通声明可以重复，这个不可以(同级)，保证唯一<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> test&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> test::a</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span> <span class="comment">//error conflict</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> test::a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//9</span></span><br><span class="line">        cout &lt;&lt; ::a &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">        cout &lt;&lt; test::a &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>using编译与using声明的区别是，在声明域中，冲突会隐藏<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> test &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> test;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// error 因为此时a在两个命名空间中，test和全局</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//9</span></span><br><span class="line">    cout &lt;&lt; test::a &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>嵌套</li>
<li>匿名<br>乱七八糟的，需要的时候再看</li>
</ol>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp template</title>
    <url>/2024/04/cpp/base/cpp_template/</url>
    <content><![CDATA[<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li><p>类型参数：什么时候编译器会自动推导？推导出什么类型</p>
</li>
<li><p>非类型参数：</p>
</li>
</ul>
<h2 id="结构体模板"><a href="#结构体模板" class="headerlink" title="结构体模板"></a>结构体模板</h2>]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp type</title>
    <url>/2024/01/cpp/base/cpp_type/</url>
    <content><![CDATA[<h2 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h2><p>编译期可以得到计算结果，且不会改变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a =<span class="number">10</span>;<span class="comment">//ok</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = a+<span class="number">1</span>;<span class="comment">//ok</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">10</span><span class="comment">//error</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="built_in">f</span>()<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>将变量声明为constexpr类型，可以由编译器验证变量是否是常量表达式<br>如果你认为它是，就把它声明为常量表达式</p>
<ul>
<li>constexpr函数<ul>
<li>函数返回值及所有形参类型都得是字面值</li>
<li>隐式内联</li>
<li>只有return语句，也可以包含空语句，类型别名，using等不执行操作的语句</li>
<li>允许constexpr函数返回值为非常量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">8</span>*a;</span><br><span class="line">&#125;<span class="comment">//若传入的a不是常量表达式，则该函数就不是常量表达式</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>常量表达式需要在编译时计算，因此在表达式里面用到的简单类型叫字面值类型</p>
<ul>
<li>算术类型</li>
<li>引用</li>
<li>指针</li>
<li>字面值常量类</li>
</ul>
<h4 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h4><h4 id="指针的初始值："><a href="#指针的初始值：" class="headerlink" title="指针的初始值："></a>指针的初始值：</h4><ol>
<li>0（nullpr）</li>
<li>某个固定地址，如定义与函数体之外的对象</li>
</ol>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp class</title>
    <url>/2024/01/cpp/oop/cpp_class/</url>
    <content><![CDATA[<span id="more"></span>
<blockquote>
<p>class和struct定义类的唯一区别是默认访问权限<br>访问权限是class level而不是obj level，类内部可以访问一个实例的私有变量</p>
</blockquote>
<h2 id="类型成员"><a href="#类型成员" class="headerlink" title="类型成员"></a>类型成员</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span></span><br><span class="line"><span class="keyword">typename</span></span><br></pre></td></tr></table></figure>
<h2 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h2><p>mutable修饰</p>
<ol>
<li>const对象的成员也可变</li>
<li>在常成员函数(const修饰)内可也变</li>
</ol>
<h2 id="常成员函数和-this"><a href="#常成员函数和-this" class="headerlink" title="常成员函数和*this"></a>常成员函数和*this</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function">A&amp; <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const函数内部的this指针为<code>const T* this</code><br>返回<strong>const引用</strong>，就不能接着调用非const函数了</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>；</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">B::g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">g</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fa = A.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>本质上都是函数，不属于类</li>
<li>单向无传递性</li>
</ul>
<h2 id="类静态变量和静态函数"><a href="#类静态变量和静态函数" class="headerlink" title="类静态变量和静态函数"></a>类静态变量和静态函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a =<span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::b = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> A::b = <span class="number">1</span>;<span class="comment">//error,见2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> A::b =<span class="number">1</span>;<span class="comment">//error,见1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>不能在类声明中定义，因为类的声明一般放在头文件中，若可以，那么当多个文件包含该头文件，之后这些文件链接时会产生重定义，因此只能在类外定义，且在函数之外，且只能定义一次</li>
<li>此static非彼static,类（cpp）static意义是使对象共享变量，<strong>在该类中是静态的</strong>,而在类外，相当于普通变量（不是静态，外文件可以访问）<br>先这样理解，这篇文章写的很好<br><a href="https://www.zhihu.com/question/397086631">知乎</a></li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h3><ul>
<li>当没有定义构造函数时，编译器会提供一个<strong>合成的默认的构造函数</strong>，否则需要(最好这样做)自行提供默认构造函数</li>
<li>两种提供默认构造函数的方式方式，一是无参，二是缺省</li>
<li>构造函数重载</li>
<li>default</li>
<li>explicit禁止隐式调用，见类型转换</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _a,<span class="type">int</span> _b):<span class="built_in">a</span>(_a),<span class="built_in">b</span>(_b)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量型，引用型，类成员为没有默认构造函数的类类型，必须使用初始化列表</li>
<li>顺序：严格按照定义顺序依次初始化，先在初始化列表中查找是否指定了初始化方式；若找到，按指定初始化；若没找到，按无参构造初始化(内置类型的值不确定)；若没找到无参构造函数，则报错；全部完成后，再进入构造函数的{ }</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> _a):<span class="built_in">a</span>(_a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;<span class="comment">//ok</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">()</span></span>;<span class="comment">//error,这是一个返回值为A类型的函数声明</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//ok</span></span><br><span class="line">A a = <span class="built_in">A</span>();<span class="comment">//ok,c++标准允许编译器使用两种方式构造，一是同上，二是先构造一个临时对象，之后拷贝丢弃，gcc上是一</span></span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>()<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myString</span> &#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* s;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myString</span>(<span class="type">const</span> <span class="type">char</span> _s[] = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_s) &#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(_s) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(s, _s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">myString</span>(<span class="type">const</span> myString&amp; _string) &#123;</span><br><span class="line">        s = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(_string.s) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(s, _string.s);</span><br><span class="line">    &#125;</span><br><span class="line">    myString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> myString&amp; _string) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;_string)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] s;</span><br><span class="line">        s = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(_string.s) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(s, _string.s);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">myString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">get_s</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><ul>
<li>默认浅拷贝，需要时自行提供深拷贝（自定义）</li>
<li>private修饰自定义拷贝构造函数，禁止拷贝，或<code>myString(const myString&amp; s)=delete</code></li>
<li>应用场景<ol>
<li>值传参</li>
<li>值返回</li>
<li><code>myString s1(s)</code> or <code>myString s1=s</code></li>
</ol>
</li>
</ul>
<h2 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h2><ol>
<li><code>return *this</code> 返回引用类型，是为了使表达式返回原来的变量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T a = b = c;</span><br></pre></td></tr></table></figure></li>
<li>检查自我赋值</li>
</ol>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>没什么东西</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2>]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp oopBase</title>
    <url>/2024/01/cpp/oop/cpp_oopBase/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p><img src="/pic/oopbase-1.png"><br><img src="/pic/oopbase-2.png"></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>先基后派生,基类若是无参构造（默认或自定义或缺省），初始化列表项可以不写基类</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><blockquote>
<p>目前就我所知，就两种情况下必须写析构：1，类的成员数据里有不能自动释放的资源。比如Windows程序的HANDLE，Linux程序的file descriptor等等。2，你要写一个基类，期望用它来派生出各种子类。这时基类必须写虚析构函数，且至少必须有一个函数体，哪怕是空的。如果基类不写虚析构函数，则子类对象的析构有可能得不到调用，从而造成资源泄露。（这是因为如果你不写，则编译器会补上一个非虚析构函数，从而阻碍了晚绑定在析构函数上发生）如果基类写了虚析构函数，但是没写函数体，则连接器会报错。（这是因为子类的析构函数在最后会隐含的调用父类的析构函数，调用一个没有实现的函数会让连接器“找不到symbol”）3，还有一种情况，不能说必须写析构，但析构往往是一个很好的地方，用来做未尽之事宜。比如你写个全局配置信息类，构造时从某数据源（如配置文件、注册表、数据库等）读取配置，中途可以接受用户反复修改配置，那么析构可以用来将新配置信息写回数据源。再如你写个网络协议，设计一个类来代表会话，那么析构可以用来向对方发送一句拜拜。</p>
</blockquote>
<h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p>本质上就是构造函数，顺序基类-&gt;派生类内子对象-&gt;派生类</p>
<ol>
<li>派生类无自定义拷贝构造，则派生类使用默认拷贝构造，该拷贝构造会调用基类和子对象的拷贝构造，若基类或子对象无自定义的拷贝构造，则同样使用默认。。。依次迭代</li>
<li>派生类有自定义的拷贝构造<ol>
<li>若不在初始化列表指定，则默认调用基类和子对象的<strong>无参构造函数</strong>（默认或自定义或缺省），若没有则报错</li>
<li>在初始化列表指定<code>Derived(const Derived&amp; rhs):Base(rhs),inobj(rhs.a)</code>这种是调用拷贝构造，或是指定构造，略</li>
</ol>
</li>
</ol>
<h2 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h2><h2 id="override-overload-overwrite"><a href="#override-overload-overwrite" class="headerlink" title="override overload overwrite"></a>override overload overwrite</h2><h2 id="多继承和虚基类"><a href="#多继承和虚基类" class="headerlink" title="多继承和虚基类"></a>多继承和虚基类</h2><p>命名冲突问题</p>
<ol>
<li>overwrite</li>
<li>using</li>
<li>虚基类</li>
</ol>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp oopVirtual</title>
    <url>/2024/01/cpp/oop/cpp_oopVirtual/</url>
    <content><![CDATA[<h2 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h2><ol>
<li>模板</li>
<li>函数重载<span id="more"></span></li>
</ol>
<h2 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h2><h3 id="编联"><a href="#编联" class="headerlink" title="编联"></a>编联</h3><ul>
<li>静态编联，编译期决定调用</li>
<li>动态编联<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态编联</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;面积是 :&quot;</span> &lt;&lt; <span class="built_in">Area</span>() &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> w, <span class="type">float</span> h) &#123;</span><br><span class="line">        mWidth = w;</span><br><span class="line">        mHeight = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mWidth * mHeight; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> mWidth, mHeight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    rect.<span class="built_in">Show</span>();<span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="继承下的类型转换"><a href="#继承下的类型转换" class="headerlink" title="继承下的类型转换"></a>继承下的类型转换</h3><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="虚函数和析构"><a href="#虚函数和析构" class="headerlink" title="虚函数和析构"></a>虚函数和析构</h4><h4 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h4><ul>
<li>虚函数表<ul>
<li>指针数组，指向函数入口地址</li>
<li>一个类只有一个，在首次实例化创建</li>
<li>顺序，前半部分和基类对应（为了方便寻找</li>
</ul>
</li>
<li>机制<ul>
<li>vptr是一个指针，指向虚函数表<br><img src="/../../pic/oop2virtual-1.png"></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda reduce</title>
    <url>/2024/03/gpu/cuda_opt/reduce/</url>
    <content><![CDATA[<p>reduce本质是一组向量运算，满足交换律和结合律，比如一组向量的和、一组向量的最大值<br><img src="/pic/reduce-1.png"></p>
<span id="more"></span>
<p>具体思路如上图所示，每个线程块处理一组数据，之后将每个线程块的结果拿出来，再由一个线程块处理。</p>
<ul>
<li>op5之前是nv的官方教程，有些过时，看看思路</li>
<li>op6使用shuffle指令，这个是重点</li>
</ul>
<p>参考文章：<br><a href="./reduction.pdf">官方教程</a><br><a href="https://zhuanlan.zhihu.com/p/426978026">有了琦琦的棍子</a><br><a href="https://zhuanlan.zhihu.com/p/596012674">BBuf</a><br><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1711529201&ver=5163&signature=4keLvSGMDuzYkg8qdEcEHcPOvaSSg4sX*BTfecKXO8rzwlkdm3KcMJuxNmC*F1Wxu4OzaMwQOnrXoCdNOqfaFmoISMp0kpPYNiYflu4HLice2Iu*nqPV3wnvPSZt3V7F&new=1">zzk</a><br><a href="https://zhuanlan.zhihu.com/p/635456406">用一个函数来得到最终的归约值</a></p>
<h2 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h2><p><img src="/pic/reduce-2.png"><br>基本思想：</p>
<ul>
<li>加速存取过程，将向量存储到共享内存中去,这样整个reduce过程以线程块为单位</li>
</ul>
<h2 id="op1：减少线程束分化"><a href="#op1：减少线程束分化" class="headerlink" title="op1：减少线程束分化"></a>op1：减少线程束分化</h2><p>在baseline的图中，<br>第一次迭代，t0、t2、t4、t6…<br>第二次迭代，t0、t4、t8…<br>一个线程束内的线程并未同步执行，可以这样<br><img src="/pic/reduce-3.png"><br>这样会造成后边的线程啥都没干，op4解决</p>
<h2 id="op2：解决板块冲突"><a href="#op2：解决板块冲突" class="headerlink" title="op2：解决板块冲突"></a>op2：解决板块冲突</h2><p>在op1的图中，以一个warp内为例<br>第一次迭代，t0访问共享内存0（bank0），1（bank1）…t16访问共享内存32（bank0），33（bank1）…二路<br>第二次迭代，t0访问共享内存0（bank0），2（bank2）…t8访问共享内存32（bank0），34（bank2）…四路<br>会发现，随着迭代次数的增加，冲突越来越多<br>解决方法，for循环反着写，简单画画就明白了</p>
<blockquote>
<p>cuda c编程权威指南中相邻配对-&gt;交错配对</p>
</blockquote>
<h2 id="op3：idle线程"><a href="#op3：idle线程" class="headerlink" title="op3：idle线程"></a>op3：idle线程</h2><p>op1中，后半线程啥都没干，直接取消就行<br>也就是说，假设原来一个块256个线程，处理256个数据，现在只需要128个线程即可<br>在参考文章中，是让256个线程先把<strong>两个256的数据块相加</strong>，之后用前128个线程处理256数据块</p>
<blockquote>
<p>按照cuda c编程权威指南中是展开循环的优化</p>
</blockquote>
<p>总之，结果还是让后128个线程有活干，虽然只做了一次加法</p>
<h2 id="op4：展开最后一个线程束"><a href="#op4：展开最后一个线程束" class="headerlink" title="op4：展开最后一个线程束"></a>op4：展开最后一个线程束</h2><p>当进行到最后几轮迭代时，此时的block中只有warp0在干活时，线程还在进行同步操作</p>
<blockquote>
<p>有大问题，计算能力7.0开始，warp中的线程是有可能不同步的了，若步调不一致，则计算结果会出现错误。<br>后边还有把for完全循环展开的优化，没必要！！！</p>
</blockquote>
<h2 id="op5：设置合理的block数量"><a href="#op5：设置合理的block数量" class="headerlink" title="op5：设置合理的block数量"></a>op5：设置合理的block数量</h2><p>怎么设置O:O?</p>
<h2 id="op6：使用shuffle指令"><a href="#op6：使用shuffle指令" class="headerlink" title="op6：使用shuffle指令"></a>op6：使用shuffle指令</h2><p><a href="https://forums.developer.nvidia.com/t/what-does-mask-mean-in-warp-shuffle-functions-shfl-sync/67697">https://forums.developer.nvidia.com/t/what-does-mask-mean-in-warp-shuffle-functions-shfl-sync/67697</a><br><a href="https://zhuanlan.zhihu.com/p/572820783">https://zhuanlan.zhihu.com/p/572820783</a></p>
<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ol>
<li>精度问题：大量的浮点数加法cpu和gpu运算结果差距太大</li>
<li>gpu整形除法和取模操作成本很高</li>
<li>架构问题：<a href="https://zhengqm.github.io/blog/2018/12/07/cuda-nvcc-tips.html">https://zhengqm.github.io/blog/2018/12/07/cuda-nvcc-tips.html</a></li>
<li>线程束同步问题:<a href="https://blog.csdn.net/weixin_42730667/article/details/109838089">https://blog.csdn.net/weixin_42730667/article/details/109838089</a></li>
<li>shuffle指令</li>
<li>测试问题，大数据量，多次？ 带宽怎么算的？</li>
</ol>
<h2 id="评论区"><a href="#评论区" class="headerlink" title="评论区"></a>评论区</h2><blockquote>
<p>大佬您好，这边再跟您讨论一点比较琐碎的东西，希望您发表一下看法。<br>在Volta架构使用Independent Thread Scheduling以后，由于每个线程都有自己的PC和stack，所以不能随意的假设warp threads在什么时候收敛，什么时候是没有分支的；不能随意的假设代码是lock-step执行的，假设warp内线程的写操作一定会被其他“看见”，这样不安全。在任何情况下，warp内某一线程或线程组完全可能比别的线程或线程组推进的更快。<br>所以，在官方给出的关于Volta新特性的例子中，关于reduction的写法，采用了利用寄存器将读写完全分离，并用__syncthread确保同步的方法，可以参考链接：<a href="http://link.zhihu.com/?target=https://developer.nvidia.com/blog/using-cuda-warp-level-primitives/">developer.nvidia.com&#x2F;bl</a><br>官方说不安全与安全的方法我都实验了，得出的结果都是正确的，不过性能都比使用volatile的写法稍差。不过站在官方的角度，使用volatile的写法也是不安全的，可以参考链接：<a href="http://link.zhihu.com/?target=https://forums.developer.nvidia.com/t/why-syncwarp-is-necessary-in-undivergent-warp-reduction/209893">forums.developer.nvidia.com</a><br>我可以想象这样一种情况：对于语句cache[tid] +&#x3D; cache[tid+8]，包含了对shared memory的读和写。但是不能保证所有读操作完成后才进行写操作。例如，tid&#x3D;0的线程，cache[0]的更新依赖于对cache[8] 的读操作；但是由于tid&#x3D;8的线程可能推进的更快，即实际上warp内的线程是不同步，存在分支的，cache[8]的更新(写操作)：cache[8] +&#x3D; cache[16] 可能先进行，导致tid&#x3D;0的线程读到的是错误的数据。<br>虽然大多数时候线程和warp的执行确实是按照我们所想的那样在何处收敛或者lock-step，但是尤其是Volta以后，这实际上并不是cuda所保证的。我想请问您，您认为是不是只要结果正确，可以不考虑这种所谓的“安全”呢？</p>
</blockquote>
]]></content>
      <tags>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/03/gpu/cuda_sample/readme/</url>
    <content><![CDATA[<p><a href="https://github.com/NVIDIA/cuda-samples">https://github.com/NVIDIA/cuda-samples</a></p>
]]></content>
  </entry>
</search>
